
AVRA   Ver. 1.3.0 Main.asm Sat May 23 19:37:40 2015


          .include "m32def.inc"
         ;***************************************************************************
         ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
         ;* 
         ;* Number		        :AVR000
         ;* File Name		    :"m32def.inc"
         ;* Title		        :Register/Bit Definitions for the ATmega32
         ;* Date                 :99.08.25
         ;* Version              :1.00
         ;* Support telephone	:+47 72 88 43 88 (ATMEL Norway)
         ;* Support fax		    :+47 72 88 43 99 (ATMEL Norway)
         ;* Support E-mail	    :avr@atmel.no
         ;* Target MCU		    :ATmega32
         ;*
         ;* DESCRIPTION
         ;* When including this file in the assembly program file, all I/O register	
         ;* names and I/O register bit names appearing in the data book can be used.
         ;* In addition, the six registers forming the three data pointers X, Y and
         ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
         ;* SRAM is also defined 
         ;*
         ;* The Register names are represented by their hexadecimal address.
         ;* 
         ;* The Register Bit names are represented by their bit number (0-7).
         ;* 
         ;* Please observe the difference in using the bit names with instructions
         ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc" 
         ;* (skip if bit in register set/cleared). The following example illustrates
         ;* this:
         ;* 
         ;* in	r16,PORTB		;read PORTB latch
         ;* sbr	r16,(1<<PB6)+(1<<PB5)	;set PB6 and PB5 (use masks, not bit#)
         ;* out  PORTB,r16		;output to PORTB
         ;*
         ;* in	r16,TIFR		;read the Timer Interrupt Flag Register
         ;* sbrc	r16,TOV0		;test the overflow flag (use bit#)
         ;* rjmp	TOV0_is_set		;jump if set
         ;* ...				;otherwise do something else
         ;***************************************************************************
         
         ;***** Specify Device
          .device ATmega32
         
         ;***** I/O Register Definitions
          .equ	SREG	=$3f
          .equ	SPH	    =$3e
          .equ	SPL	    =$3d
          .equ	OCR0	=$3c
          .equ	GIMSK	=$3b		; For compatibility, keep both names until further
          .equ	GICR	=$3b		; new name for GIMSK
          .equ	GIFR	=$3a
          .equ	TIMSK	=$39
          .equ	TIFR	=$38
          .equ	SPMCR	=$37
          .equ    TWCR    =$36
          .equ    MCUCR   =$35
          .equ    MCUSR   =$34		; For compatibility, 
          .equ    MCUCSR  =$34		; keep both names until further
          .equ	TCCR0	=$33
          .equ	TCNT0	=$32
          .equ    OSCCAL  =$31
          .equ    SFIOR   =$30
          .equ	TCCR1A	=$2f
          .equ	TCCR1B	=$2e
          .equ	TCNT1H	=$2d
          .equ	TCNT1L	=$2c
          .equ	OCR1AH	=$2b
          .equ	OCR1AL	=$2a
          .equ	OCR1BH	=$29
          .equ	OCR1BL	=$28
          .equ	ICR1H	=$27
          .equ	ICR1L	=$26
          .equ	TCCR2	=$25
          .equ	TCNT2	=$24
          .equ	OCR2	=$23
          .equ	ASSR	=$22
          .equ	WDTCR	=$21
          .equ    UBRRH   =$20		;  Note! UCSRC equals UBRRH
          .equ	EEARH	=$1f
          .equ	EEARL	=$1e
          .equ	EEDR	=$1d
          .equ	EECR	=$1c
          .equ	PORTA	=$1b
          .equ	DDRA	=$1a
          .equ	PINA	=$19
          .equ	PORTB	=$18
          .equ	DDRB	=$17
          .equ	PINB	=$16
          .equ	PORTC	=$15
          .equ	DDRC	=$14
          .equ	PINC	=$13
          .equ	PORTD	=$12
          .equ	DDRD	=$11
          .equ	PIND	=$10
          .equ	SPDR	=$0f
          .equ	SPSR	=$0e
          .equ	SPCR	=$0d
          .equ	UDR	    =$0c
          .equ	UCSRA	=$0b
          .equ	UCSRB	=$0a
          .equ	UCSRC	=$20		;  Note! UCSRC equals UBRRH
          .equ	UBRRL	=$09
          .equ	ACSR	=$08
          .equ    ADMUX   =$07
          .equ    ADCSR   =$06
          .equ    ADCH    =$05
          .equ    ADCL    =$04
          .equ    TWDR    =$03
          .equ    TWAR    =$02
          .equ    TWSR    =$01
          .equ    TWBR    =$00
         
         
         
         ;***** Bit Definitions
         ;GIMSK
          .equ	INT1	=7
          .equ	INT0	=6
          .equ	INT2	=5
          .equ	IVSEL	=1		; interrupt vector select
          .equ	IVCE	=0		; interrupt vector change enable
         
         ;GIFR
          .equ	INTF1	=7
          .equ	INTF0	=6
          .equ	INTF2	=5
         
         ;TIMSK
          .equ    TOIE0   =0
          .equ    OCIE0   =1
          .equ    TOIE1   =2
          .equ    OCIE1B  =3
          .equ    OCIE1A  =4
          .equ    TICIE1  =5
          .equ    TOIE2   =6
          .equ    OCIE2   =7
         
         ;TIFR
          .equ    TOV0    =0
          .equ    OCF0    =1
          .equ    TOV1    =2
          .equ    OCF1B   =3
          .equ    OCF1A   =4
          .equ    ICF1    =5
          .equ    TOV2    =6
          .equ    OCF2    =7
         
         ;SPMCR
          .equ	SPMIE	=7
          .equ	ASB	=6
          .equ	ASRE	=4
          .equ	BLBSET	=3
          .equ	PGWRT	=2
          .equ	PGERS	=1
          .equ	SPMEN	=0
         
         ;MCUCR
          .equ    SE      =7
          .equ    SM2     =6
          .equ    SM1     =5
          .equ    SM0     =4
          .equ    ISC11   =3
          .equ    ISC10   =2
          .equ    ISC01   =1
          .equ    ISC00   =0
         
         ;MCUCSR
          .equ	JTD     =7	
          .equ    ISC2    =6
          .equ    EIH     =5
          .equ    JTRF    =4	
          .equ    WDRF    =3
          .equ    BORF    =2
          .equ    EXTRF   =1
          .equ    PORF    =0
         
         ;TCCR0
          .equ    FOC0    =7
          .equ    PWM0    =6
          .equ	COM01	=5
          .equ	COM00	=4
          .equ	CTC0	=3
          .equ	CS02	=2
          .equ	CS01	=1
          .equ	CS00	=0
         
         ;TCCR1A
          .equ	COM1A1	=7
          .equ	COM1A0	=6
          .equ	COM1B1	=5
          .equ	COM1B0	=4
          .equ	FOC1A	=3
          .equ	FOC1B	=2
          .equ	PWM11	=1
          .equ	PWM10	=0
         
         ;TCCR1B
          .equ	ICNC1	=7
          .equ	ICES1	=6
          .equ	CTC11	=4
          .equ	CTC10	=3
          .equ	CTC1	=3		; Obsolete - Included for backward compatibility
          .equ	CS12	=2
          .equ	CS11	=1
          .equ	CS10	=0
         
         ;TCCR2
          .equ	FOC2	=7
          .equ    PWM2    =6
          .equ    COM21   =5
          .equ    COM20   =4
          .equ    CTC2    =3
          .equ    CS22    =2
          .equ    CS21    =1
          .equ    CS20    =0
         
         ;SFIOR
          .equ    RPDD    =7
          .equ    RPDC    =6
          .equ    RPDB    =5
          .equ    RPDA    =4
          .equ    ACME    =3
          .equ    PUD     =2
          .equ	PSR2	=1
          .equ	PSR10	=0
         
         ;WDTCR
          .equ	WDTOE	=4
          .equ	WDE	=3
          .equ	WDP2	=2
          .equ	WDP1	=1
          .equ	WDP0	=0
         
         ;EECR
          .equ    EERIE   =3
          .equ	EEMWE	=2
          .equ	EEWE	=1
          .equ	EERE	=0
         
         ;PORTA
          .equ	PA7	=7
          .equ	PA6	=6
          .equ	PA5	=5
          .equ	PA4	=4
          .equ	PA3	=3
          .equ	PA2	=2
          .equ	PA1	=1
          .equ	PA0	=0
         
         ;DDRA
          .equ	DDA7	=7
          .equ	DDA6	=6
          .equ	DDA5	=5
          .equ	DDA4	=4
          .equ	DDA3	=3
          .equ	DDA2	=2
          .equ	DDA1	=1
          .equ	DDA0	=0
         
         ;PINA
          .equ	PINA7	=7
          .equ	PINA6	=6
          .equ	PINA5	=5
          .equ	PINA4	=4
          .equ	PINA3	=3
          .equ	PINA2	=2
          .equ	PINA1	=1
          .equ	PINA0	=0
         
         ;PORTB
          .equ	PB7	=7
          .equ	PB6	=6
          .equ	PB5	=5
          .equ	PB4	=4
          .equ	PB3	=3
          .equ	PB2	=2
          .equ	PB1	=1
          .equ	PB0	=0
         
         ;DDRB
          .equ	DDB7	=7
          .equ	DDB6	=6
          .equ	DDB5	=5
          .equ	DDB4	=4
          .equ	DDB3	=3
          .equ	DDB2	=2
          .equ	DDB1	=1
          .equ	DDB0	=0
         
         ;PINB
          .equ	PINB7	=7
          .equ	PINB6	=6
          .equ	PINB5	=5
          .equ	PINB4	=4
          .equ	PINB3	=3
          .equ	PINB2	=2
          .equ	PINB1	=1
          .equ	PINB0	=0
         
         ;PORTC
          .equ	PC7	=7
          .equ	PC6	=6
          .equ	PC5	=5
          .equ	PC4	=4
          .equ	PC3	=3
          .equ	PC2	=2
          .equ	PC1	=1
          .equ	PC0	=0
         
         ;DDRC
          .equ	DDC7	=7
          .equ	DDC6	=6
          .equ	DDC5	=5
          .equ	DDC4	=4
          .equ	DDC3	=3
          .equ	DDC2	=2
          .equ	DDC1	=1
          .equ	DDC0	=0
         
         ;PINC
          .equ	PINC7	=7
          .equ	PINC6	=6
          .equ	PINC5	=5
          .equ	PINC4	=4
          .equ	PINC3	=3
          .equ	PINC2	=2
          .equ	PINC1	=1
          .equ	PINC0	=0
         
         ;PORTD
          .equ	PD7	=7
          .equ	PD6	=6
          .equ	PD5	=5
          .equ	PD4	=4
          .equ	PD3	=3
          .equ	PD2	=2
          .equ	PD1	=1
          .equ	PD0	=0
         
         ;DDRD
          .equ	DDD7	=7
          .equ	DDD6	=6
          .equ	DDD5	=5
          .equ	DDD4	=4
          .equ	DDD3	=3
          .equ	DDD2	=2
          .equ	DDD1	=1
          .equ	DDD0	=0
         
         ;PIND
          .equ	PIND7	=7
          .equ	PIND6	=6
          .equ	PIND5	=5
          .equ	PIND4	=4
          .equ	PIND3	=3
          .equ	PIND2	=2
          .equ	PIND1	=1
          .equ	PIND0	=0
         
         ;UCSRA
          .equ	RXC	=7
          .equ	TXC	=6
          .equ	UDRE	=5
          .equ	FE	=4
          .equ	OR	=3		; old name kept for compatibilty
          .equ	DOR	=3
          .equ	PE	=2
          .equ	U2X	=1
          .equ	MPCM	=0
         
         ;UCSRB
          .equ	RXCIE	=7
          .equ	TXCIE	=6
          .equ	UDRIE	=5
          .equ	RXEN	=4
          .equ	TXEN	=3
          .equ	CHR9	=2		; old name kept for compatibilty
          .equ	UCSZ2	=2
          .equ	RXB8	=1
          .equ	TXB8	=0
         
         ;UCSRC
          .equ	URSEL	=7
          .equ	UMSEL	=6
          .equ	UPM1	=5
          .equ	UPM0	=4
          .equ	USBS	=3
          .equ	UCSZ1	=2
          .equ	UCSZ0	=1
          .equ	UCPOL	=0
         		
         ;SPCR
          .equ	SPIE	=7
          .equ	SPE	=6
          .equ	DORD	=5
          .equ	MSTR	=4
          .equ	CPOL	=3
          .equ	CPHA	=2
          .equ	SPR1	=1
          .equ	SPR0	=0
         
         ;SPSR
          .equ	SPIF	=7
          .equ	WCOL	=6
          .equ	SPI2X	=0
         
         ;ACSR
          .equ	ACD	=7
          .equ    ACBG    =6
          .equ	ACO	=5
          .equ	ACI	=4
          .equ	ACIE	=3
          .equ	ACIC	=2
          .equ	ACIS1	=1
          .equ	ACIS0	=0
         
         ;ADMUX
          .equ    REFS1   =7
          .equ    REFS0   =6
          .equ    ADLAR   =5
          .equ    MUX4    =4
          .equ    MUX3    =3
          .equ    MUX2    =2
          .equ    MUX1    =1
          .equ    MUX0    =0
         
         ;ADCSR
          .equ    ADEN    =7
          .equ    ADSC    =6
          .equ    ADFR    =5
          .equ    ADIF    =4
          .equ    ADIE    =3
          .equ    ADPS2   =2
          .equ    ADPS1   =1
          .equ    ADPS0   =0
         
         ; TWCR
          .equ    TWINT   =7
          .equ    TWEA    =6
          .equ    TWSTA   =5
          .equ    TWSTO   =4
          .equ    TWWC    =3
          .equ    TWEN    =2
          .equ    TWI_TST =1  ;Present in core test mode only. Write Only.
          .equ    TWIE    =0
         
         ; TWAR
          .equ    TWGCE   =0
         
         ;ASSR
          .equ    AS2     =3
          .equ    TCN2UB  =2
          .equ    OCR2UB  =1
          .equ    TCR2UB  =0
         
          .def	XL	=r26
          .def	XH	=r27
          .def	YL	=r28
          .def	YH	=r29
          .def	ZL	=r30
          .def	ZH	=r31
         
          .equ 	FLASHEND	=$3FFF
          .equ 	E2END	    =$3FF
          .equ	RAMEND	    =$85F
         
         			;  byte groups
         			;  /\/--\/--\/--\ 
          .equ 	SMALLBOOTSTART	=0b11111100000000  ;($3F00) smallest boot block is 256W
          .equ 	SECONDBOOTSTART	=0b11111000000000  ;($3E00) 2'nd boot block size is 512W
          .equ 	THIRDBOOTSTART	=0b11110000000000  ;($3C00) third boot block size is 1KW
          .equ 	LARGEBOOTSTART	=0b11100000000000  ;($3800) largest boot block is 2KW
          .equ 	BOOTSTART	=THIRDBOOTSTART  ;OBSOLETE!!! kept for compatibility
          .equ	PAGESIZE	=64     ;number of WORDS in a page
         
         
          .equ	INT0addr=$002	; External Interrupt0 Vector Address
          .equ	INT1addr=$004	; External Interrupt1 Vector Address
          .equ	INT2addr=$006	; External Interrupt2 Vector Address
          .equ	OC2addr =$008	; Output Compare2 Interrupt Vector Address
          .equ	OVF2addr=$00a	; Overflow2 Interrupt Vector Address
          .equ	ICP1addr=$00c	; Input Capture1 Interrupt Vector Address
          .equ	OC1Aaddr=$00e	; Output Compare1A Interrupt Vector Address
          .equ	OC1Baddr=$010	; Output Compare1B Interrupt Vector Address
          .equ	OVF1addr=$012	; Overflow1 Interrupt Vector Address
          .equ	OC0addr =$014	; Output Compare0 Interrupt Vector Address
          .equ	OVF0addr=$016	; Overflow0 Interrupt Vector Address
          .equ	SPIaddr =$018	; SPI Interrupt Vector Address
          .equ	URXCaddr=$01a	; USART Receive Complete Interrupt Vector Address
          .equ	UDREaddr=$01c	; USART Data Register Empty Interrupt Vector Address
          .equ	UTXCaddr=$01e	; USART Transmit Complete Interrupt Vector Address
          .equ	ADCCaddr=$020	; ADC Interrupt Vector Address
          .equ	ERDYaddr=$022	; EEPROM Interrupt Vector Address
          .equ	ACIaddr =$024	; Analog Comparator Interrupt Vector Address
          .equ    TWSIaddr=$026   ; Irq. vector address for Two-Wire Interface
          .equ	SPMRaddr=$028	; Store Program Memory Ready Interrupt Vector Address
         
         
         
          
         
         ;Mapping of all the interrupts, must be the first include!
          .include "Interrupt_Mapping.asm"
         ;Interrupt vector mapping
          .org 0x00
C:000000 c336      rjmp Init
         ;External interrupt1
         ;.org 0x04
         ;jmp	Input_Capture
         ;Timer1 Input Capture interrupt
          .org	0x0C
C:00000c 940c 01df jmp	Input_Capture
         ;Timer0 CTC interrupt
          .org 0x14
C:000014 940c 01b1 jmp Timer0_Update
         ;USART received interrupt
          .org 0x1A
C:00001a 940c 0273 jmp Comm_Received
         ;Comparator interrupt
          .org 0x24
C:000024 940c 0228 jmp Lap_Time
         
         ;Library includes
          .include "Macros.asm"
          .MACRO Push_Register_5
          	push	@0
          	push	@1
          	push	@2
          	push	@3
          	push	@4
          	in	R16, SREG
          	push	R16
          .ENDMACRO
         
          .MACRO Pop_Register_5
          	pop	R16
          	out	SREG, R16
          	pop	@0
          	pop	@1
          	pop	@2
          	pop	@3
          	pop	@4	
          .ENDMACRO
         
          .MACRO Push_Register_7
          	push	@0
          	push	@1
          	push	@2
          	push	@3
          	push	@4
          	push	@5
          	push	@6
          	in	R16, SREG
          	push	R16
          .ENDMACRO
         
          .MACRO Pop_Register_7
          	pop	R16
          	out	SREG, R16
          	pop	@0
          	pop	@1
          	pop	@2
          	pop	@3
          	pop	@4
          	pop	@5
          	pop	@6	
          .ENDMACRO
         
          .MACRO Set_SREG_1 
          			lds		R16, SREG_1
          			sbr		R16, (1<<@0)					; set bit in R16 (performs a logical ORI instruction)
          			sts		SREG_1, R16
          .ENDMACRO
         
          .MACRO Clear_SREG_1 
          			lds		R16, SREG_1
          			cbr		R16, (1<<@0)					; clear bit in R16 (performs logical AND with complement of operand)
          			sts		SREG_1, R16
          .ENDMACRO
         
          
          .include "Math.asm"
          Sum_16:
C:000026 0f02      	add R16, R18
C:000027 1f13      	adc R17, R19
C:000028 9508      ret
         
          Div16_8:
         	
C:000029 27ff      	clr ZH ;Kvotient high
C:00002a 27ee      	clr ZL ;Kvotient low
         
          Div16_8_Loop:
         
C:00002b 9631      	adiw ZH:ZL, 1 ;Kvotient ++
         
C:00002c 1b02      	sub R16 ,R18 ;Træk nævner fra tæller
C:00002d 4010      	sbci R17, 0
C:00002e f7e0      	brcc Div16_8_Loop
         	
C:00002f 9731      	sbiw ZH:ZL, 1 ;Kvotient --
         
C:000030 0f02      	add R16, R18 ;Læg nævner til
         	
C:000031 2f20      	mov R18, R16
C:000032 018f      	movw R17:R16,ZH:ZL
         
C:000033 9508      ret
          .include "SRAM-Mapping.asm"
         ;Mapping of the data memory
         ;SRAM starts at 0x60
         
         ;Accelerometer dataset from the MPU6050
          .equ ACCEL_XOUT_H = 0x0060
          .equ ACCEL_XOUT_L = 0x0061
          .equ ACCEL_YOUT_H = 0x0062
          .equ ACCEL_YOUT_L = 0x0063
          .equ ACCEL_ZOUT_H = 0x0064
          .equ ACCEL_ZOUT_L = 0x0065
         
         ;Temperature dataset from the MPU6050
          .equ TEMP_OUT_H   = 0x0066
          .equ TEMP_OUT_L   = 0x0067
         
         ;Gyro dataset from the MPU6050
          .equ GYRO_XOUT_H  = 0x0068
          .equ GYRO_XOUT_L  = 0x0069
          .equ GYRO_YOUT_H  = 0x006A
          .equ GYRO_YOUT_L  = 0x006B
          .equ GYRO_ZOUT_H  = 0x006C
          .equ GYRO_ZOUT_L  = 0x006D
         
         ;Time0 variables
          .equ Timer_1ms_H  = 0x006E
          .equ Timer_1ms_M  = 0x006F
          .equ Timer_1ms_L  = 0x0070
         
         ;Finish line time stamp
          .equ Time_Stamp_H = 0x0071
          .equ Time_Stamp_M = 0x0072
          .equ Time_Stamp_L = 0x0073
         
         ;Latest lap time
          .equ Lap_time_L   = 0x0074
          .equ Lap_time_M	  = 0x0075
          .equ Lap_time_H	  = 0x0076
         
         ;Wheelspeed stuff
          .equ Edge1_L		= 0x0077
          .equ Edge1_H		= 0x0078
          .equ Pulse_Time_L	= 0x0079
          .equ Pulse_Time_H	= 0x007A
         
          .equ Ticks_L		= 0x007B
          .equ Ticks_H		= 0x007C
         
          .equ Ticks_Lap_L	= 0x007D
          .equ Ticks_Lap_H	= 0x007E
         
         ;Status Register
          .equ SREG_1			= 0x007F
         
         ;Communication Protocol stuff
          .equ Comm_Received_Byte_Num = 0x0080
          .equ Comm_Received_Byte_1 = 0x0081
          .equ Comm_Received_Byte_2 = 0x0082
          .equ Comm_Received_Byte_3 = 0x0083
         
         ;Delay stuff
          .equ Delay_Ticks		  = 0x0084	
          .equ Delay_Amount		  = 0x0085
          .include "USART_Library.asm"
          ; USART_library.asm
          ; Author: StjerneIdioten
         
          .MACRO  USART_Init
         	;Set Baud Rate to 9600
          	ldi R16,	@1	
          	ldi R17,	@0
          
          	out	UBRRH,	R17
          	out UBRRL,	R16
          
         	;Enable receiver and transmitter
          	ldi R16,	(1<<RXEN)|(1<<TXEN)|(1<<RXCIE)
          	out	UCSRB,	R16
          
         	;Set frame format: 8data, 1stop bit
          	ldi	R16,	(1<<URSEL)|(3<<UCSZ0)
          	out	UCSRC,	R16
          .ENDMACRO
         
          ;Waits for an empty transmit buffer and then moves R16 to the transmit buffer
           USART_Transmit: 
           USART_Transmit_Start:
         	; Wait for empty transmit buffer
C:000034 9b5d      	sbis	UCSRA,	UDRE
C:000035 cffe      	rjmp	USART_Transmit_Start
C:000036 b90c      	out	UDR, R16
C:000037 9508      ret
         
         
         ;Waits for a byte to be recived and outputs it to R16
          USART_Receive:
          USART_Receive_Start:
         	; Wait for data to be received
C:000038 9b5f      	sbis UCSRA, RXC
C:000039 cffe      	rjmp USART_Receive_Start
         	; Get and return received data from buffer
C:00003a b10c      	in r16, UDR
C:00003b 9508      ret
         
         
         ;Outputs a newline to serial. In the format of '\r\n'
          .Macro USART_Newline
          	ldi R16, 0x0D
          	call USART_Transmit 
          	ldi R16, 0x0A
          	call USART_Transmit 
          .ENDMACRO
         
         
         ;Outputs the byte in R16 as a string of 8 ascii 1's or 0's
          USART_Binary:
C:00003c 2f10      	mov R17, R16			;Copy R16 to R17
C:00003d e020      	ldi R18, 0x00			;Set the counter to zero
          USART_Binary_Loop:
C:00003e ff17      	sbrs R17, 7				;Skip if bit 7 in R17 is set
C:00003f c004      	rjmp USART_Binary_0		;Jump here if the it was 0
C:000040 e301      	ldi R16, '1'			;Load in ascii 1 in R16
C:000041 940e 0034 	call USART_Transmit		;Transmit the 1
C:000043 c003      	rjmp USART_Binary_End	;Jump to the end
          USART_Binary_0:				
C:000044 e300      	ldi R16, '0'			;Load in ascii 0 in R16
C:000045 940e 0034 	call USART_Transmit
          USART_Binary_End:
C:000047 0f11      	lsl R17					;Left shift R17
C:000048 9523      	inc R18					;Increment R18
C:000049 3028      	cpi R18, 0x08			;Check if we have converted and sent an entire byte yet
C:00004a f799      	brne USART_Binary_Loop	;Repeat if we haven't
C:00004b 9508      ret
         
         
         
         ;Expecs a 16 bit value in R17:R16
          USART_Decimal_S16:
         
C:00004c 0198      	movw R19:R18, R17:R16
C:00004d ff37      	sbrs R19, 7
C:00004e c007      	rjmp USART_Decimal_S16_Count_10000
         
          USART_Decimal_S16_Signed:
C:00004f e20d      	ldi R16, '-'
C:000050 940e 0034 	call USART_Transmit
C:000052 5021      	subi R18, 0x01
C:000053 4030      	sbci R19, 0x00
C:000054 9520      	com R18
C:000055 9530      	com R19
         
          USART_Decimal_S16_Count_10000:
C:000056 2744      	clr R20
C:000057 e2b7      	ldi XH, HIGH(10000)
C:000058 e1a0      	ldi XL, LOW(10000)
          USART_Decimal_S16_Count_10000_Loop:
C:000059 9543      	inc R20
C:00005a 1b2a      	sub R18, XL
C:00005b 0b3b      	sbc R19, XH
C:00005c f7e0      	brcc USART_Decimal_S16_Count_10000_Loop
C:00005d 954a      	dec R20
C:00005e 0f2a      	add R18, XL
C:00005f 1f3b      	adc R19, XH
C:000060 e300      	ldi R16, 0x30
C:000061 0f04      	add R16, R20
C:000062 940e 0034 	call USART_Transmit
         
          USART_Decimal_S16_Count_1000:
C:000064 2744      	clr R20
C:000065 e0b3      	ldi XH, HIGH(1000)
C:000066 eea8      	ldi XL, LOW(1000)
          USART_Decimal_S16_Count_1000_Loop:
C:000067 9543      	inc R20
C:000068 1b2a      	sub R18, XL
C:000069 0b3b      	sbc R19, XH
C:00006a f7e0      	brcc USART_Decimal_S16_Count_1000_Loop
C:00006b 954a      	dec R20
C:00006c 0f2a      	add R18, XL
C:00006d 1f3b      	adc R19, XH
C:00006e e300      	ldi R16, 0x30
C:00006f 0f04      	add R16, R20
C:000070 940e 0034 	call USART_Transmit
         
          USART_Decimal_S16_Count_100:
C:000072 2744      	clr R20
C:000073 e0b0      	ldi XH, HIGH(100)
C:000074 e6a4      	ldi XL, LOW(100)
          USART_Decimal_S16_Count_100_Loop:
C:000075 9543      	inc R20
C:000076 1b2a      	sub R18, XL
C:000077 0b3b      	sbc R19, XH
C:000078 f7e0      	brcc USART_Decimal_S16_Count_100_Loop
C:000079 954a      	dec R20
C:00007a 0f2a      	add R18, XL
C:00007b 1f3b      	adc R19, XH
C:00007c e300      	ldi R16, 0x30
C:00007d 0f04      	add R16, R20
C:00007e 940e 0034 	call USART_Transmit
         
          USART_Decimal_S16_Count_10:
C:000080 2744      	clr R20
C:000081 e0b0      	ldi XH, HIGH(10)
C:000082 e0aa      	ldi XL, LOW(10)
          USART_Decimal_S16_Count_10_Loop:
C:000083 9543      	inc R20
C:000084 1b2a      	sub R18, XL
C:000085 0b3b      	sbc R19, XH
C:000086 f7e0      	brcc USART_Decimal_S16_Count_10_Loop
C:000087 954a      	dec R20
C:000088 0f2a      	add R18, XL
C:000089 1f3b      	adc R19, XH
C:00008a e300      	ldi R16, 0x30
C:00008b 0f04      	add R16, R20
C:00008c 940e 0034 	call USART_Transmit
         
          USART_Decimal_S16_Count_1:
C:00008e 2744      	clr R20
C:00008f e0b0      	ldi XH, HIGH(1)
C:000090 e0a1      	ldi XL, LOW(1)
          USART_Decimal_S16_Count_1_Loop:
C:000091 9543      	inc R20
C:000092 1b2a      	sub R18, XL
C:000093 0b3b      	sbc R19, XH
C:000094 f7e0      	brcc USART_Decimal_S16_Count_1_Loop
C:000095 954a      	dec R20
C:000096 0f2a      	add R18, XL
C:000097 1f3b      	adc R19, XH
C:000098 e300      	ldi R16, 0x30
C:000099 0f04      	add R16, R20
C:00009a 940e 0034 	call USART_Transmit
         
C:00009c 9508      ret
         
         
         ;Expecs a 16 bit value in R17:R16
          USART_Decimal_16:
         
C:00009d 0198      	movw R19:R18, R17:R16
         
          USART_Decimal_16_Count_10000:
C:00009e 2744      	clr R20
C:00009f e2b7      	ldi XH, HIGH(10000)
C:0000a0 e1a0      	ldi XL, LOW(10000)
          USART_Decimal_16_Count_10000_Loop:
C:0000a1 9543      	inc R20
C:0000a2 1b2a      	sub R18, XL
C:0000a3 0b3b      	sbc R19, XH
C:0000a4 f7e0      	brcc USART_Decimal_16_Count_10000_Loop
C:0000a5 954a      	dec R20
C:0000a6 0f2a      	add R18, XL
C:0000a7 1f3b      	adc R19, XH
C:0000a8 e300      	ldi R16, 0x30
C:0000a9 0f04      	add R16, R20
C:0000aa 940e 0034 	call USART_Transmit
         
          USART_Decimal_16_Count_1000:
C:0000ac 2744      	clr R20
C:0000ad e0b3      	ldi XH, HIGH(1000)
C:0000ae eea8      	ldi XL, LOW(1000)
          USART_Decimal_16_Count_1000_Loop:
C:0000af 9543      	inc R20
C:0000b0 1b2a      	sub R18, XL
C:0000b1 0b3b      	sbc R19, XH
C:0000b2 f7e0      	brcc USART_Decimal_16_Count_1000_Loop
C:0000b3 954a      	dec R20
C:0000b4 0f2a      	add R18, XL
C:0000b5 1f3b      	adc R19, XH
C:0000b6 e300      	ldi R16, 0x30
C:0000b7 0f04      	add R16, R20
C:0000b8 940e 0034 	call USART_Transmit
         
          USART_Decimal_16_Count_100:
C:0000ba 2744      	clr R20
C:0000bb e0b0      	ldi XH, HIGH(100)
C:0000bc e6a4      	ldi XL, LOW(100)
          USART_Decimal_16_Count_100_Loop:
C:0000bd 9543      	inc R20
C:0000be 1b2a      	sub R18, XL
C:0000bf 0b3b      	sbc R19, XH
C:0000c0 f7e0      	brcc USART_Decimal_16_Count_100_Loop
C:0000c1 954a      	dec R20
C:0000c2 0f2a      	add R18, XL
C:0000c3 1f3b      	adc R19, XH
C:0000c4 e300      	ldi R16, 0x30
C:0000c5 0f04      	add R16, R20
C:0000c6 940e 0034 	call USART_Transmit
         
          USART_Decimal_16_Count_10:
C:0000c8 2744      	clr R20
C:0000c9 e0b0      	ldi XH, HIGH(10)
C:0000ca e0aa      	ldi XL, LOW(10)
          USART_Decimal_16_Count_10_Loop:
C:0000cb 9543      	inc R20
C:0000cc 1b2a      	sub R18, XL
C:0000cd 0b3b      	sbc R19, XH
C:0000ce f7e0      	brcc USART_Decimal_16_Count_10_Loop
C:0000cf 954a      	dec R20
C:0000d0 0f2a      	add R18, XL
C:0000d1 1f3b      	adc R19, XH
C:0000d2 e300      	ldi R16, 0x30
C:0000d3 0f04      	add R16, R20
C:0000d4 940e 0034 	call USART_Transmit
         
          USART_Decimal_16_Count_1:
C:0000d6 2744      	clr R20
C:0000d7 e0b0      	ldi XH, HIGH(1)
C:0000d8 e0a1      	ldi XL, LOW(1)
          USART_Decimal_16_Count_1_Loop:
C:0000d9 9543      	inc R20
C:0000da 1b2a      	sub R18, XL
C:0000db 0b3b      	sbc R19, XH
C:0000dc f7e0      	brcc USART_Decimal_16_Count_1_Loop
C:0000dd 954a      	dec R20
C:0000de 0f2a      	add R18, XL
C:0000df 1f3b      	adc R19, XH
C:0000e0 e300      	ldi R16, 0x30
C:0000e1 0f04      	add R16, R20
C:0000e2 940e 0034 	call USART_Transmit
         
C:0000e4 9508      ret
          .include "Delays.asm"
         ;Author: Jonas A. L. Andersen
         
         ;Requires the Timer library made by Kristian! And the SRAM-Mapping.asm
         ;These macros are intended for a micro running 16MHZ
         
         ;This macro can generate from 1 to 255 ms of delay.  
         ;Uses R16, R17 and R18
          .MACRO	DELAY_MS_M					; Cycles to execute 
          	LDI R16, @0 ;					; 1 cycle to execute
          	DELAY_MS_M_2: ;-----------------/
          	LDI R17, 15 ;	              /
          	DELAY_MS_M_1:	;------------/    /
          	LDI R18, 177;		     /    /
          	DELAY_MS_M_0: ;-------/    /    /
          	NOP ;			    /C   /B   /A
          	NOP ;				/	 /	  /
          	NOP ;				/	 /	  /
          	DEC R18 ;		    /    /    /
          	BRNE DELAY_MS_M_0 ;---/    /    /
          	DEC R17 ;		         /    /
          	NOP ;					 /	  /
          	BRNE DELAY_MS_M_1 ;--------/    /
          	DEC R16 ;		              /
          	NOP ;						  /
          	NOP ;						  /
          	NOP ;						  /
          	NOP ;						  /
          	NOP ;						  /
          	NOP ;						  /
          	BRNE DELAY_MS_M_2 ;-------------/
          .ENDMACRO
         ; Block C: 177*(1+1+1+1+2)-1 = 1061
         ; Block B: 15*(1+C+1+1+2)-1 = 15990 
         ; Block A: x*(1+B+1+1+1+1+1+1+1+2)-1 = x*16000-1
         ; Total # of cycles is: 1 + A = x*16000 
         ; Formula for delay: x*1ms
         
          Delay_MS:
C:0000e5 2e90      	mov R9, R16
C:0000e6 9030 0070 	lds R3, Timer_1ms_L
C:0000e8 9040 006f 	lds R4, Timer_1ms_M
C:0000ea 9050 006e 	lds R5, Timer_1ms_H
         
          Delay_MS_Loop:
         	
C:0000ec 9478      	sei
C:0000ed 9060 0070 	lds R6, Timer_1ms_L
C:0000ef 9070 006f 	lds R7, Timer_1ms_M
C:0000f1 9080 006e 	lds R8, Timer_1ms_H
         
C:0000f3 94f8      	cli
C:0000f4 1863      	sub R6, R3
C:0000f5 0874      	sbc R7, R4
C:0000f6 0885      	sbc R8, R5
         
C:0000f7 1469      	cp R6, R9
         
C:0000f8 f398      	brlo Delay_MS_Loop
C:0000f9 9478      	sei
C:0000fa 9508      ret
          .include "Motor_Control.asm"
          .EQU	MOTOR_PIN = PD7						;The pin that the motor is connected to
          .EQU	BRAKE_PIN = PB0
         
          .MACRO Motor_Init
          	in R16, DDRD							;Load in the current setup of the portb
          	ori R16, (1<<PD7)						;OR in the setup that we wish to have
          	out DDRD, R16
          
          	ldi R16, 0b01101001						;Fast-pwm, non-inverting mode, no prescaling
          	out TCCR2, R16							;
          .ENDMACRO
         
         ; Use desired braking time in MS as argument
          .MACRO Brake_MS
          		
          .ENDMACRO
         
          Motor_Set: 
C:0000fb bd03      	out OCR2, R16							;Set the duty cycle of the motor
C:0000fc 9508      ret
         
          .MACRO Brake_Init
          
          	in R16, DDRB							;Load in the current setup of the portc
          	ori R16, (1<<BRAKE_PIN)					;OR in the setup that we wish to have
          	out DDRB, R16							;Set brake pin as output
          	
          	cbi	PORTB, BRAKE_PIN					;Set brake to high state
          
          .ENDMACRO
         
          Motor_Set_Percentage:
C:0000fd 3605      	cpi R16, 101							;Check if the number is within the percentage range of 100
C:0000fe f460      	brsh Motor_Set_Percentage_End			;Branch if not
         
C:0000ff ef1f      	ldi R17, 255							;Using the formula (N*255)/100=N% of 255
C:000100 9f01      	mul R16, R17							;Multiply the number by 255
         
C:000101 2d00      	mov R16, R0								;The multiplication hardware leaves the result in R1:R0
C:000102 2d11      	mov R17, R1								;
         
C:000103 e624      	ldi R18, 100							;Load in the 100 to divide with
C:000104 940e 0029 	call Div16_8							;Divide with 100, the rest is returned in R18
         
C:000106 3322      	cpi R18, 50								;Check to see if we should round of or down.
C:000107 f008      	brlo Motor_Set_Percentage_Out			;R16 is actually the trunctuated value of the divison which is the same as rounding down.
C:000108 9503      	inc R16									;Increment if we were rounding up
         
          Motor_Set_Percentage_Out:
         
C:000109 940e 00fb 	call Motor_Set							;Set the duty cycle of the motor pwn as the % of 255
         
          Motor_Set_Percentage_End:
C:00010b 9508       ret
          .include "I2C.asm"
         ;Author: StjerneIdioten
         ;I2C communication library 
         
           .equ I2C_ACK = 0x01	;Value for ACK used with I2C_Read
           .equ I2C_NACK = 0x00	;Value for NACK used with I2C_Read
         
           .MACRO I2C_Init ;First argument is prescaler, second argument is TWBR
         	;Set Prescaler
          	ldi R16, @0
          	out TWSR, R16
          	
         	;Set TWBR
          	ldi R16, @1
          	out TWBR, R16
          
         	;Enable I2C module
          	ldi R16, (1<<TWEN)
          	out TWCR, R16
          
          	nop ;Important delay to allow the module to start
          
           .ENDMACRO
         
         
         ;This function sends a start command
          I2C_Start:
         	;Send Start condition
C:00010c ea04      	ldi r16, (1<<TWINT)|(1<<TWSTA)|(1<<TWEN) 
C:00010d bf06      	out TWCR, r16
         
          I2C_Start_Wait:	
         	;Wait for the start condition transmit			
C:00010e b706      	in r16,TWCR
C:00010f ff07      	sbrs r16,TWINT
C:000110 cffd      	rjmp I2C_Start_Wait
C:000111 9508      ret
         
         
         ;This function sends a stop command
          I2C_Stop:
         	;Send Stop condition
C:000112 e904      	ldi r16, (1<<TWINT)|(1<<TWSTO)|(1<<TWEN) 
C:000113 bf06      	out TWCR, r16
C:000114 9508      ret
         
         
         ;This function writes the data from R16, onto the I2C data line
          I2C_Write_Call:
C:000115 b903      	out TWDR, r16
C:000116 e804      	ldi r16, (1<<TWINT) | (1<<TWEN)
C:000117 bf06      	out TWCR, r16
         
          I2C_Write_Call_Wait:
C:000118 b706      	in r16,TWCR
C:000119 ff07      	sbrs r16,TWINT
C:00011a cffd      	rjmp I2C_Write_Call_Wait
C:00011b 9508      ret
         
         ;This is an easy to use macro of the write function
          .MACRO I2C_Write
          	ldi R16, @0
          	call I2C_Write_Call
          .ENDMACRO
         
         ;This function reads in data from the I2C data line and stores it in R16.
         ;Remember to set R16 to either I2C_ACK or I2C_NACK before calling the function!
         ;Failure to do so may result in unwanted behaviour.
          I2C_Read_Call:
C:00011c fd00      	sbrc r16,0
C:00011d c002      	rjmp I2C_Read_Call_ACK
C:00011e e804      	ldi r16, (1<<TWINT) | (1<<TWEN)
C:00011f c001      	rjmp I2C_Read_Call_Continue
          I2C_Read_Call_ACK:
C:000120 ec04      	ldi r16, (1<<TWINT) | (1<<TWEN) | (1<<TWEA)
          I2C_Read_Call_Continue:
C:000121 bf06      	out TWCR, r16
          I2C_Read_Call_Wait:
C:000122 b706      	in r16,TWCR
C:000123 ff07      	sbrs r16,TWINT
C:000124 cffd      	rjmp I2C_Read_Call_Wait
         
C:000125 b103      	in R16, TWDR
C:000126 9508      ret
         
         ;Easy to use macro which takes I2C_Ack/I2C_Nack as argument.
          .MACRO I2C_Read
          	ldi R16, @0
          	call I2C_Read_Call
          .ENDMACRO
         
         
          
          .include "MPU-6050.inc"
          .equ MPU6050_ADDRESS_W = 0b11010000 ; Address with end write bit
          .equ MPU6050_ADDRESS_R = 0b11010001 ; Address with end read bit
          .equ MPU6050_RA_XG_OFFS_TC = 0x00 ;[7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
          .equ MPU6050_RA_YG_OFFS_TC = 0x01 ;[7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD
          .equ MPU6050_RA_ZG_OFFS_TC = 0x02 ;[7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD
          .equ MPU6050_RA_X_FINE_GAIN = 0x03 ;[7:0] X_FINE_GAIN
          .equ MPU6050_RA_Y_FINE_GAIN = 0x04 ;[7:0] Y_FINE_GAIN
          .equ MPU6050_RA_Z_FINE_GAIN = 0x05 ;[7:0] Z_FINE_GAIN
          .equ MPU6050_RA_XA_OFFS_H = 0x06 ;[15:0] XA_OFFS
          .equ MPU6050_RA_XA_OFFS_L_TC = 0x07
          .equ MPU6050_RA_YA_OFFS_H = 0x08 ;[15:0] YA_OFFS
          .equ MPU6050_RA_YA_OFFS_L_TC = 0x09
          .equ MPU6050_RA_ZA_OFFS_H = 0x0A ;[15:0] ZA_OFFS
          .equ MPU6050_RA_ZA_OFFS_L_TC = 0x0B
          .equ MPU6050_RA_XG_OFFS_USRH = 0x13 ;[15:0] XG_OFFS_USR
          .equ MPU6050_RA_XG_OFFS_USRL = 0x14
          .equ MPU6050_RA_YG_OFFS_USRH = 0x15 ;[15:0] YG_OFFS_USR
          .equ MPU6050_RA_YG_OFFS_USRL = 0x16
          .equ MPU6050_RA_ZG_OFFS_USRH = 0x17 ;[15:0] ZG_OFFS_USR
          .equ MPU6050_RA_ZG_OFFS_USRL = 0x18
          .equ MPU6050_RA_SMPLRT_DIV = 0x19
          .equ MPU6050_RA_CONFIG = 0x1A
          .equ MPU6050_RA_GYRO_CONFIG = 0x1B
          .equ MPU6050_RA_ACCEL_CONFIG = 0x1C
          .equ MPU6050_RA_FF_THR = 0x1D
          .equ MPU6050_RA_FF_DUR = 0x1E
          .equ MPU6050_RA_MOT_THR = 0x1F
          .equ MPU6050_RA_MOT_DUR = 0x20
          .equ MPU6050_RA_ZRMOT_THR = 0x21
          .equ MPU6050_RA_ZRMOT_DUR = 0x22
          .equ MPU6050_RA_FIFO_EN = 0x23
          .equ MPU6050_RA_I2C_MST_CTRL = 0x24
          .equ MPU6050_RA_I2C_SLV0_ADDR = 0x25
          .equ MPU6050_RA_I2C_SLV0_REG = 0x26
          .equ MPU6050_RA_I2C_SLV0_CTRL = 0x27
          .equ MPU6050_RA_I2C_SLV1_ADDR = 0x28
          .equ MPU6050_RA_I2C_SLV1_REG = 0x29
          .equ MPU6050_RA_I2C_SLV1_CTRL = 0x2A
          .equ MPU6050_RA_I2C_SLV2_ADDR = 0x2B
          .equ MPU6050_RA_I2C_SLV2_REG = 0x2C
          .equ MPU6050_RA_I2C_SLV2_CTRL = 0x2D
          .equ MPU6050_RA_I2C_SLV3_ADDR = 0x2E
          .equ MPU6050_RA_I2C_SLV3_REG = 0x2F
          .equ MPU6050_RA_I2C_SLV3_CTRL = 0x30
          .equ MPU6050_RA_I2C_SLV4_ADDR = 0x31
          .equ MPU6050_RA_I2C_SLV4_REG = 0x32
          .equ MPU6050_RA_I2C_SLV4_DO = 0x33
          .equ MPU6050_RA_I2C_SLV4_CTRL = 0x34
          .equ MPU6050_RA_I2C_SLV4_DI = 0x35
          .equ MPU6050_RA_I2C_MST_STATUS = 0x36
          .equ MPU6050_RA_INT_PIN_CFG = 0x37
          .equ MPU6050_RA_INT_ENABLE = 0x38
          .equ MPU6050_RA_DMP_INT_STATUS = 0x39
          .equ MPU6050_RA_INT_STATUS = 0x3A
          .equ MPU6050_RA_ACCEL_XOUT_H = 0x3B
          .equ MPU6050_RA_ACCEL_XOUT_L = 0x3C
          .equ MPU6050_RA_ACCEL_YOUT_H = 0x3D
          .equ MPU6050_RA_ACCEL_YOUT_L = 0x3E
          .equ MPU6050_RA_ACCEL_ZOUT_H = 0x3F
          .equ MPU6050_RA_ACCEL_ZOUT_L = 0x40
          .equ MPU6050_RA_TEMP_OUT_H = 0x41
          .equ MPU6050_RA_TEMP_OUT_L = 0x42
          .equ MPU6050_RA_GYRO_XOUT_H = 0x43
          .equ MPU6050_RA_GYRO_XOUT_L = 0x44
          .equ MPU6050_RA_GYRO_YOUT_H = 0x45
          .equ MPU6050_RA_GYRO_YOUT_L = 0x46
          .equ MPU6050_RA_GYRO_ZOUT_H = 0x47
          .equ MPU6050_RA_GYRO_ZOUT_L = 0x48
          .equ MPU6050_RA_EXT_SENS_DATA_00 = 0x49
          .equ MPU6050_RA_EXT_SENS_DATA_01 = 0x4A
          .equ MPU6050_RA_EXT_SENS_DATA_02 = 0x4B
          .equ MPU6050_RA_EXT_SENS_DATA_03 = 0x4C
          .equ MPU6050_RA_EXT_SENS_DATA_04 = 0x4D
          .equ MPU6050_RA_EXT_SENS_DATA_05 = 0x4E
          .equ MPU6050_RA_EXT_SENS_DATA_06 = 0x4F
          .equ MPU6050_RA_EXT_SENS_DATA_07 = 0x50
          .equ MPU6050_RA_EXT_SENS_DATA_08 = 0x51
          .equ MPU6050_RA_EXT_SENS_DATA_09 = 0x52
          .equ MPU6050_RA_EXT_SENS_DATA_10 = 0x53
          .equ MPU6050_RA_EXT_SENS_DATA_11 = 0x54
          .equ MPU6050_RA_EXT_SENS_DATA_12 = 0x55
          .equ MPU6050_RA_EXT_SENS_DATA_13 = 0x56
          .equ MPU6050_RA_EXT_SENS_DATA_14 = 0x57
          .equ MPU6050_RA_EXT_SENS_DATA_15 = 0x58
          .equ MPU6050_RA_EXT_SENS_DATA_16 = 0x59
          .equ MPU6050_RA_EXT_SENS_DATA_17 = 0x5A
          .equ MPU6050_RA_EXT_SENS_DATA_18 = 0x5B
          .equ MPU6050_RA_EXT_SENS_DATA_19 = 0x5C
          .equ MPU6050_RA_EXT_SENS_DATA_20 = 0x5D
          .equ MPU6050_RA_EXT_SENS_DATA_21 = 0x5E
          .equ MPU6050_RA_EXT_SENS_DATA_22 = 0x5F
          .equ MPU6050_RA_EXT_SENS_DATA_23 = 0x60
          .equ MPU6050_RA_MOT_DETECT_STATUS = 0x61
          .equ MPU6050_RA_I2C_SLV0_DO = 0x63
          .equ MPU6050_RA_I2C_SLV1_DO = 0x64
          .equ MPU6050_RA_I2C_SLV2_DO = 0x65
          .equ MPU6050_RA_I2C_SLV3_DO = 0x66
          .equ MPU6050_RA_I2C_MST_DELAY_CTRL = 0x67
          .equ MPU6050_RA_SIGNAL_PATH_RESET = 0x68
          .equ MPU6050_RA_MOT_DETECT_CTRL = 0x69
          .equ MPU6050_RA_USER_CTRL = 0x6A
          .equ MPU6050_RA_PWR_MGMT_1 = 0x6B
          .equ MPU6050_RA_PWR_MGMT_2 = 0x6C
          .equ MPU6050_RA_BANK_SEL = 0x6D
          .equ MPU6050_RA_MEM_START_ADDR = 0x6E
          .equ MPU6050_RA_MEM_R_W = 0x6F
          .equ MPU6050_RA_DMP_CFG_1 = 0x70
          .equ MPU6050_RA_DMP_CFG_2 = 0x71
          .equ MPU6050_RA_FIFO_COUNTH = 0x72
          .equ MPU6050_RA_FIFO_COUNTL = 0x73
          .equ MPU6050_RA_FIFO_R_W = 0x74
          .equ MPU6050_RA_WHO_AM_I = 0x75
          .include "MPU-6050.asm"
         ;This library is for the 6DOF MPU-6050 from invensense.
         ;This library relies on the I2C library made by StjerneIdioten.
         ;This library relies on the "MPU-6050.inc" where all the definitions of registers are defined.
         ;This library relies on having defined the correct SRAM locations prior to reading in data.
         
         ;Setup the MPU-6050
          .MACRO MPU6050_Init
          
          	call I2C_Start							;Send a start									
          	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
          
          	I2C_Write MPU6050_RA_SMPLRT_DIV			;Write the address to start the burst write at
          
         	;Sets sample rate to 8000/1+7 = 1000Hz
          	I2C_Write 0x07
          
         	;MPU6050_RA_CONFIG, Disable FSync, 256Hz DLPF
          	I2C_Write 0x00
          
         	;MPU6050_RA_GYRO_CONFIG, Disable gyro self tests, scale of 500 degrees/s
          	I2C_Write 0b00001000
          
         	;MPU6050_RA_ACCEL_CONFIG ,Disable accel self tests, scale of +-16g, no DHPF
          	I2C_Write 0b00001000
          
         	;MPU6050_RA_FF_THR ,Freefall threshold of |0mg|
          	I2C_Write 0x00
          
         	;MPU6050_RA_FF_DUR ,Freefall duration limit of 0
          	I2C_Write 0x00
          
         	;MPU6050_RA_MOT_THR ,Motion threshold of 0mg
          	I2C_Write 0x00
          
         	;MPU6050_RA_MOT_DUR ,Motion duration of 0s
          	I2C_Write 0x00
          
         	;MPU6050_RA_ZRMOT_THR ,Zero motion threshold
          	I2C_Write 0x00
          
         	;MPU6050_RA_ZRMOT_DUR ,Zero motion duration threshold
          	I2C_Write 0x00
          
         	;MPU6050_RA_FIFO_EN ,Disable sensor output to FIFO buffer
          	I2C_Write 0x00
          
         	;Aux I2C setup
         	;MPU6050_RA_I2C_MST_CTRL, Sets AUX I2C to single master control, plus other config
          	I2C_Write 0x00
          
         	;Setup AUX I2C slaves
         	;MPU6050_RA_I2C_SLV0_ADDR
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV0_REG
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV0_CTR
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV1_ADDR
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV1_REG
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV1_CTRL
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV2_ADDR
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV2_REG
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV2_CTRL
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV3_ADDR
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV3_REG
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV3_CTRL
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV4_ADDR
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV4_REG
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV4_DO
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV4_CTRL
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV4_DI
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_MST_STATUS ;Read-only
          
         	;MPU6050_RA_INT_PIN_CFG, Setup INT pin and AUX I2C pass through
          	call I2C_Start							;Send a start
          	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
          
          	I2C_Write MPU6050_RA_INT_PIN_CFG		;Write the address to start the burst write at
          	I2C_Write 0x00							;Clear the register and burst write
          
         	;MPU6050_RA_INT_ENABLE, Enable data ready interrupt
              I2C_Write 0x00
          
         	;MPU6050_RA_DMP_INT_STATUS				;Read-only
             ;MPU6050_RA_INT_STATUS 3A				;Read-only
             ;MPU6050_RA_ACCEL_XOUT_H				;Read-only
             ;MPU6050_RA_ACCEL_XOUT_L				;Read-only
             ;MPU6050_RA_ACCEL_YOUT_H				;Read-only
             ;MPU6050_RA_ACCEL_YOUT_L				;Read-only
             ;MPU6050_RA_ACCEL_ZOUT_H				;Read-only
             ;MPU6050_RA_ACCEL_ZOUT_L				;Read-only
             ;MPU6050_RA_TEMP_OUT_H					;Read-only
             ;MPU6050_RA_TEMP_OUT_L					;Read-only
             ;MPU6050_RA_GYRO_XOUT_H					;Read-only
             ;MPU6050_RA_GYRO_XOUT_L					;Read-only
             ;MPU6050_RA_GYRO_YOUT_H					;Read-only
             ;MPU6050_RA_GYRO_YOUT_L					;Read-only
             ;MPU6050_RA_GYRO_ZOUT_H					;Read-only
             ;MPU6050_RA_GYRO_ZOUT_L					;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_00			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_01			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_02			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_03			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_04			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_05			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_06			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_07			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_08			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_09			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_10			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_11			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_12			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_13			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_14			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_15			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_16			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_17			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_18			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_19			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_20			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_21			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_22			;Read-only
             ;MPU6050_RA_EXT_SENS_DATA_23			;Read-only
             ;MPU6050_RA_MOT_DETECT_STATUS			;Read-only
          
         	;Slave out, dont care
          
         	;MPU6050_RA_I2C_SLV0_DO
          	call I2C_Start							;Send a start
          	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
          
          	I2C_Write MPU6050_RA_I2C_SLV0_DO		;Write the address to start the burst write at
          	I2C_Write 0x00							;Clear the register and burst write
          
         	;MPU6050_RA_I2C_SLV1_DO
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV2_DO
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_SLV3_DO
          	I2C_Write 0x00
          
         	;MPU6050_RA_I2C_MST_DELAY_CTRL, More slave config
          	I2C_Write 0x00
          
         	;MPU6050_RA_SIGNAL_PATH_RESET, Reset sensor signal paths
          	I2C_Write 0x00
          
         	;MPU6050_RA_MOT_DETECT_CTRL, Motion detection control
          	I2C_Write 0x00
          
         	;MPU6050_RA_USER_CTRL, Disables FIFO, AUX I2C, FIFO and I2C reset bits to 0
          	I2C_Write 0x00
          
         	;MPU6050_RA_PWR_MGMT_1, Sets clock source to gyro reference w/ PLL
          	I2C_Write 0b00000010
          
         	;MPU6050_RA_PWR_MGMT_2, Controls frequency of wakeups in accel low power mode plus the sensor standby modes
          	I2C_Write 0x00
          
         	;MPU6050_RA_BANK_SEL					;Not in datasheet
             ;MPU6050_RA_MEM_START_ADDR				;Not in datasheet
             ;MPU6050_RA_MEM_R_W						;Not in datasheet
             ;MPU6050_RA_DMP_CFG_1					;Not in datasheet
             ;MPU6050_RA_DMP_CFG_2					;Not in datasheet
             ;MPU6050_RA_FIFO_COUNTH					;Read-only
             ;MPU6050_RA_FIFO_COUNTL					;Read-only
          
             ;Data transfer to and from the FIFO buffer
          	call I2C_Start							;Send a start
          	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
          
          	I2C_Write MPU6050_RA_FIFO_R_W			;Write the address of the FIFO buffer register
          	I2C_Write 0x00							;Write zero to disable it.
          
         	;MPU6050_RA_WHO_AM_I					;Read-only, I2C address
          
          	call I2C_Stop							;Send a stop
          .ENDMACRO
         
         
         ;This macro gets the value stored in the Who_Am_I register in the MPU-6050. This will always return 0x68 independent of AD0! Useful for testing the connection.
          .MACRO MPU6050_Get_Address
          	call I2C_Start							;Send a start
          	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
          	I2C_Write MPU6050_RA_WHO_AM_I			;Write the address of the Who Am I register
          
          	call I2C_Start							;Send a start
          	I2C_Write MPU6050_ADDRESS_R				;Send the read address of the MPU6050
          
          	I2C_Read I2C_Nack						;Move the read in value to R17, because R16 is used in the stop function
          	mov R17, R16							;
          
          	call I2C_Stop							;Send a stop
          
          	mov R16, R17							;Move the read in value back into R16 
          .ENDMACRO
         
         
         ;Reads in the entire dataset supplied by the MPU6050 by doing a couple of burst reads. The values can be found at the SRAM addresses specified in SRAM-Mapping
          MPU6050_Read_Dataset:
C:000127 940e 010c 	call I2C_Start							;Send a start
C:000129   +  	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
C:000129 ed00      ldi R16, MPU6050_ADDRESS_W
C:00012a 940e 0115 call I2C_Write_Call
C:00012c   +  	I2C_Write MPU6050_RA_ACCEL_XOUT_H		;Write the address to begin reading from.
C:00012c e30b      ldi R16, MPU6050_RA_ACCEL_XOUT_H
C:00012d 940e 0115 call I2C_Write_Call
         
C:00012f 940e 010c 	call I2C_Start							;Send a repeated start
C:000131   +  	I2C_Write MPU6050_ADDRESS_R				;Send the read address of the MPU6050
C:000131 ed01      ldi R16, MPU6050_ADDRESS_R
C:000132 940e 0115 call I2C_Write_Call
         
C:000134   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000134 e001      ldi R16, I2C_Ack
C:000135 940e 011c call I2C_Read_Call
C:000137 9300 0060 	sts ACCEL_XOUT_H, R16					;Store the ACCEL_XOUT_H in SRAM
         
C:000139   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000139 e001      ldi R16, I2C_Ack
C:00013a 940e 011c call I2C_Read_Call
C:00013c 9300 0061 	sts ACCEL_XOUT_L, R16					;Store the ACCEL_XOUT_L in SRAM
         
C:00013e   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:00013e e001      ldi R16, I2C_Ack
C:00013f 940e 011c call I2C_Read_Call
C:000141 9300 0062 	sts ACCEL_YOUT_H, R16					;Store the ACCEL_YOUT_H in SRAM
         
C:000143   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000143 e001      ldi R16, I2C_Ack
C:000144 940e 011c call I2C_Read_Call
C:000146 9300 0063 	sts ACCEL_YOUT_L, R16					;Store the ACCEL_YOUT_L in SRAM
         
C:000148   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000148 e001      ldi R16, I2C_Ack
C:000149 940e 011c call I2C_Read_Call
C:00014b 9300 0064 	sts ACCEL_ZOUT_H, R16					;Store the ACCEL_ZOUT_H in SRAM
         
C:00014d   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:00014d e001      ldi R16, I2C_Ack
C:00014e 940e 011c call I2C_Read_Call
C:000150 9300 0065 	sts ACCEL_ZOUT_L, R16					;Store the ACCEL_ZOUT_L in SRAM
         
C:000152   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000152 e001      ldi R16, I2C_Ack
C:000153 940e 011c call I2C_Read_Call
C:000155 9300 0066 	sts TEMP_OUT_H, R16						;Store the TEMP_OUT_H in SRAM
         
C:000157   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000157 e001      ldi R16, I2C_Ack
C:000158 940e 011c call I2C_Read_Call
C:00015a 9300 0067 	sts TEMP_OUT_L, R16						;Store the TEMP_OUT_L in SRAM
         
C:00015c   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:00015c e001      ldi R16, I2C_Ack
C:00015d 940e 011c call I2C_Read_Call
C:00015f 9300 0068 	sts GYRO_XOUT_H, R16					;Store the GYRO_XOUT_H in SRAM
         
C:000161   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000161 e001      ldi R16, I2C_Ack
C:000162 940e 011c call I2C_Read_Call
C:000164 9300 0069 	sts GYRO_XOUT_L, R16					;Store the GYRO_XOUT_L in SRAM
         
C:000166   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000166 e001      ldi R16, I2C_Ack
C:000167 940e 011c call I2C_Read_Call
C:000169 9300 006a 	sts GYRO_YOUT_H, R16					;Store the GYRO_YOUT_H in SRAM
         	
C:00016b   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:00016b e001      ldi R16, I2C_Ack
C:00016c 940e 011c call I2C_Read_Call
C:00016e 9300 006b 	sts GYRO_YOUT_L, R16					;Store the GYRO_YOUT_L in SRAM
         	
C:000170   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:000170 e001      ldi R16, I2C_Ack
C:000171 940e 011c call I2C_Read_Call
C:000173 9300 006c 	sts GYRO_ZOUT_H, R16					;Store the GYRO_ZOUT_H in SRAM
         	
C:000175   +  	I2C_Read I2C_Nack						;Reply with an NACK to indicate that we do not wish to read the next byte too
C:000175 e000      ldi R16, I2C_Nack
C:000176 940e 011c call I2C_Read_Call
C:000178 9300 006b 	sts GYRO_YOUT_L, R16					;Store the GYRO_YOUT_L in SRAM
         
C:00017a 940e 0112 	call I2C_Stop							;Send a stop
C:00017c 9508      ret											;Return
         
          MPU6050_Read_Accel_X:
C:00017d 940e 010c 	call I2C_Start							;Send a start
C:00017f   +  	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
C:00017f ed00      ldi R16, MPU6050_ADDRESS_W
C:000180 940e 0115 call I2C_Write_Call
C:000182   +  	I2C_Write MPU6050_RA_ACCEL_XOUT_H		;Write the address to begin reading from.
C:000182 e30b      ldi R16, MPU6050_RA_ACCEL_XOUT_H
C:000183 940e 0115 call I2C_Write_Call
         
C:000185 940e 010c 	call I2C_Start							;Send a repeated start
C:000187   +  	I2C_Write MPU6050_ADDRESS_R				;Send the read address of the MPU6050
C:000187 ed01      ldi R16, MPU6050_ADDRESS_R
C:000188 940e 0115 call I2C_Write_Call
         
C:00018a   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:00018a e001      ldi R16, I2C_Ack
C:00018b 940e 011c call I2C_Read_Call
C:00018d 9300 0060 	sts ACCEL_XOUT_H, R16					;Store the ACCEL_XOUT_H in SRAM
         
C:00018f   +  	I2C_Read I2C_Nack						;Reply with an ACK to indicate that we wish to read the next byte too
C:00018f e000      ldi R16, I2C_Nack
C:000190 940e 011c call I2C_Read_Call
C:000192 9300 0061 	sts ACCEL_XOUT_L, R16					;Store the ACCEL_XOUT_L in SRAM
         
C:000194 940e 0112 	call I2C_Stop							;Send a stop
C:000196 9508      ret											;Return
         
          MPU6050_Read_Gyro_Z:
C:000197 940e 010c 	call I2C_Start							;Send a start
C:000199   +  	I2C_Write MPU6050_ADDRESS_W				;Send the write address of the MPU6050
C:000199 ed00      ldi R16, MPU6050_ADDRESS_W
C:00019a 940e 0115 call I2C_Write_Call
C:00019c   +  	I2C_Write MPU6050_RA_GYRO_ZOUT_H		;Write the address to begin reading from.
C:00019c e407      ldi R16, MPU6050_RA_GYRO_ZOUT_H
C:00019d 940e 0115 call I2C_Write_Call
         
C:00019f 940e 010c 	call I2C_Start							;Send a repeated start
C:0001a1   +  	I2C_Write MPU6050_ADDRESS_R				;Send the read address of the MPU6050
C:0001a1 ed01      ldi R16, MPU6050_ADDRESS_R
C:0001a2 940e 0115 call I2C_Write_Call
         
C:0001a4   +  	I2C_Read I2C_Ack						;Reply with an ACK to indicate that we wish to read the next byte too
C:0001a4 e001      ldi R16, I2C_Ack
C:0001a5 940e 011c call I2C_Read_Call
C:0001a7 9300 006c 	sts GYRO_ZOUT_H, R16					;Store the ACCEL_XOUT_H in SRAM
         
C:0001a9   +  	I2C_Read I2C_Nack						;Reply with an ACK to indicate that we wish to read the next byte too
C:0001a9 e000      ldi R16, I2C_Nack
C:0001aa 940e 011c call I2C_Read_Call
C:0001ac 9300 006d 	sts GYRO_ZOUT_L, R16					;Store the ACCEL_XOUT_L in SRAM
         
C:0001ae 940e 0112 	call I2C_Stop							;Send a stop
C:0001b0 9508      ret											;Return
          .include "Time.asm"
         ; This library handles all initial setup of timer operations
         
         ; Initialize timer0 to generate an output compare interrupt every 1[ms]
          .MACRO Time_Init
          			ldi		R16, 0b00001011			; CTC-mode, 1/64 prescaling -> 250 cycles pr ms.
          			out		TCCR0, R16
          			ldi		R16, 0x00
          			out		TCNT0, R16				; Counter0 initialization
          			ldi		R16, 249				; 249+1 cycles = 1[ms] for every output compare match
          			out		OCR0, R16
          			
          			clr		R16
          			sts		Timer_1ms_L, R16
          			sts		Timer_1ms_M, R16
          			sts		Timer_1ms_H, R16	
          
          			in		R16, TIMSK
          			ori		R16, (1<<OCIE0)			;Enable interrupt on output compare match for timer0
          			out		TIMSK, R16				;Timer/interrupt masking register
          			
          .ENDMACRO
         
         ; Timer subroutines
         
          Timer0_Update:
C:0001b1 930f      			push	R16
C:0001b2 b70f      			in		R16, SREG
C:0001b3 930f      			push	R16
         			
C:0001b4 e001      			ldi		R16, 0x01
C:0001b5 9000 0070 			lds		R0, Timer_1ms_L			
C:0001b7 0e00      			add		R0, R16						;Advance time by 1ms whenever timer0 has compare match
C:0001b8 9200 0070 			sts		Timer_1ms_L, R0	
C:0001ba f468      			brcc	Timer_Update_End
         			
C:0001bb e000      			ldi		R16, 0x00
C:0001bc 9010 006f 			lds		R1, Timer_1ms_M				;24 bits = 16777 seconds = 4.6 hours... ish :D
C:0001be 1e10      			adc		R1, R16
C:0001bf 9210 006f 			sts		Timer_1ms_M, R1	
C:0001c1 f430      			brcc	Timer_Update_End
         			
C:0001c2 9020 006e 			lds		R2, Timer_1ms_H
C:0001c4 1e20      			adc		R2, R16
C:0001c5 9220 006e 			sts		Timer_1ms_H, R2
C:0001c7 f400      			brcc	Timer_Update_End
         			
          Timer_Update_End:
         
         
C:0001c8 9100 007f Delay:		lds		R16, SREG_1			
C:0001ca ff07      			sbrs	R16, 7							; bit 7 is the delay enable 
C:0001cb c00f      			rjmp	Delay_End
         									
C:0001cc 9100 0084 			lds		R16, Delay_Ticks
C:0001ce 9110 0085 			lds		R17, Delay_Amount
C:0001d0 9513      			inc		R17
C:0001d1 1701      			cp		R16, R17
C:0001d2 f441      			brne	Delay_End
         			
C:0001d3 2711      			clr		R17
C:0001d4 9310 0084 			sts		Delay_Ticks, R17
         			
C:0001d6   +  			Clear_SREG_1 7							; clear bit 7 in SREG_1
C:0001d6 9100 007f lds		R16, SREG_1
C:0001d8 770f      cbr		R16, (1<<7)					

C:0001d9 9300 007f sts		SREG_1, R16
         
C:0001db 910f      Delay_End:	pop		R16
C:0001dc bf0f      			out		SREG, R16
C:0001dd 910f      			pop		R16
         			
C:0001de 9518      			reti
         			
         
          
          .include "WheelSpeed.asm"
         
          .MACRO WheelSpeed_Init
          
          			
          
          			ldi		R16, 0x00
          			out		TCCR1A, R16
          			ldi		R16, 0b00000010			; Falling edge triggered, 1/1024 prescaling
          			out		TCCR1B, R16	
          
          			clr		R16
          			sts		Edge1_L, R16
          			sts		Edge1_H, R16
          
          			sts		Ticks_L, R16
          			sts		Ticks_H, R16
          
          			in		R16, TIMSK
          			ori		R16, (1<<TICIE1)		;Enable interrupt on output compare match for timer0
          			out		TIMSK, R16				;Timer/interrupt masking register
          			
          .ENDMACRO
         
         
          Input_Capture:
         
C:0001df   +  			Push_Register_5 R0, R1, R2, R3, R16
C:0001df 920f      push	R0
C:0001e0 921f      push	R1
C:0001e1 922f      push	R2
C:0001e2 923f      push	R3
C:0001e3 930f      push	R16
C:0001e4 b70f      in	R16, SREG
C:0001e5 930f      push	R16
         			
C:0001e6 9000 007b 			lds		R0, Ticks_L
C:0001e8 9010 007c 			lds		R1, Ticks_H
         			
C:0001ea e001      			ldi		R16, 0x01
C:0001eb 0e00      			add		R0, R16
C:0001ec e000      			ldi		R16, 0x00
C:0001ed 1e10      			adc		R1, R16
         			
C:0001ee 9200 007b 			sts		Ticks_L, R0
C:0001f0 9210 007c 			sts		Ticks_H, R1			
         			
C:0001f2 9100 007f 			lds		R16, SREG_1			
C:0001f4 fd00      			sbrc	R16, 0							; bit 0 represents the current edge that's being measured - 0 = EDGE1, 1 = EDGE2
C:0001f5 c013      			rjmp	EDGE2
         			
C:0001f6 b406      EDGE1:		in		R0, ICR1L
C:0001f7 b417      			in		R1, ICR1H
         			
C:0001f8 9200 0077 			sts		Edge1_L, R0
C:0001fa 9210 0078 			sts		Edge1_H, R1
         
C:0001fc   +  			Set_SREG_1 	0
C:0001fc 9100 007f lds		R16, SREG_1
C:0001fe 6001      sbr		R16, (1<<0)					

C:0001ff 9300 007f sts		SREG_1, R16
         			
C:000201   +  			Pop_Register_5 R16, R3, R2, R1, R0
C:000201 910f      pop	R16
C:000202 bf0f      out	SREG, R16
C:000203 910f      pop	R16
C:000204 903f      pop	R3
C:000205 902f      pop	R2
C:000206 901f      pop	R1
C:000207 900f      pop	R0	
         			
C:000208 9518      			reti
         			
C:000209 9000 0077 EDGE2:		lds		R0, Edge1_L
C:00020b 9010 0078 			lds		R1, Edge1_H
         			
C:00020d b426      			in		R2, ICR1L
C:00020e b437      			in		R3, ICR1H
         			
C:00020f 1820      			sub		R2, R0
C:000210 0831      			sbc		R3, R1
         			
C:000211 e00b      			ldi		R16, high(3000)
C:000212 1630      			cp		R3, R16
C:000213 f060      			brlo	WheelSpeed_End		
         			
C:000214   +  			Clear_SREG_1 0
C:000214 9100 007f lds		R16, SREG_1
C:000216 7f0e      cbr		R16, (1<<0)					

C:000217 9300 007f sts		SREG_1, R16
         			
C:000219 e000      			ldi		R16, 0x00
C:00021a bd0d      			out		TCNT1H, R16						; Temp = R16
C:00021b bd0c      			out		TCNT1L, R16						; TCNT1L = R16 & TCNT1H = Temp	
         			
C:00021c 9220 0079 			sts		Pulse_Time_L, R2
C:00021e 9230 007a 			sts		Pulse_Time_H, R3
         
          WheelSpeed_End:
         			
C:000220   +  			Pop_Register_5 R16, R3, R2, R1, R0
C:000220 910f      pop	R16
C:000221 bf0f      out	SREG, R16
C:000222 910f      pop	R16
C:000223 903f      pop	R3
C:000224 902f      pop	R2
C:000225 901f      pop	R1
C:000226 900f      pop	R0	
         			
C:000227 9518      			reti
          .include "LapCounter.asm"
          .MACRO LapCounter_Init
          
          	clr	R16
          	sts	Time_Stamp_L, R16
          	sts	Time_Stamp_M, R16
          	sts	Time_Stamp_H, R16
          			
          	sts	Lap_time_L, R16
          	sts	Lap_time_M, R16
          	sts	Lap_time_H, R16
          
          	in R16, ACSR
          	ori R16, 0x48						;Initialize comparator with bandgap reference and enable interrupt
          	out ACSR, R16						;
          
          	in R16, SFIOR						;
          	andi R16, ~(1<<ACME)				;Disable comparator multiplexer (AIN1 = inverting input for comparator)
          	out SFIOR, R16						;
          
          	cbi DDRB,PB3						;Make PB3 input for the comparator
          
          .ENDMACRO
         
          Lap_Time:	
         
C:000228   +  	Push_Register_7 R0, R1, R2, R3, R4, R5, R16
C:000228 920f      push	R0
C:000229 921f      push	R1
C:00022a 922f      push	R2
C:00022b 923f      push	R3
C:00022c 924f      push	R4
C:00022d 925f      push	R5
C:00022e 930f      push	R16
C:00022f b70f      in	R16, SREG
C:000230 930f      push	R16
         
C:000231 9000 0070 	lds		R0, Timer_1ms_L				
C:000233 9010 006f 	lds		R1, Timer_1ms_M				; Current time since startup in ms
C:000235 9020 006e 	lds		R2, Timer_1ms_H				 
         			
C:000237 9030 0073 	lds		R3, Time_Stamp_L			
C:000239 9040 0072 	lds		R4, Time_Stamp_M			; Time stamp at start of lap
C:00023b 9050 0071 	lds		R5, Time_Stamp_H
         			
C:00023d 9200 0073 	sts		Time_Stamp_L, R0			
C:00023f 9210 0072 	sts		Time_Stamp_M, R1			; New time stamp for next lap
C:000241 9220 0071 	sts		Time_Stamp_H, R2	
         			
C:000243 1803      	sub		R0, R3						
C:000244 0814      	sbc		R1, R4						; Difference between current time and last time stamp
C:000245 0825      	sbc		R2, R5
         		
C:000246 e002      	ldi R16, 2		
C:000247 1610      	cp R1, R16
C:000248 f100      	brlo Lap_Time_End
         	
C:000249 9200 0074 	sts		Lap_time_L, R0				
C:00024b 9210 0075 	sts		Lap_time_M, R1				; Latest lap time
C:00024d 9220 0076 	sts		Lap_time_H, R2			
         	
C:00024f 9000 007b 	lds		R0, Ticks_L
C:000251 9010 007c 	lds		R1, Ticks_H
         	
C:000253 9200 007d 	sts		Ticks_Lap_L, R0
C:000255 9210 007e 	sts		Ticks_Lap_H, R1
         	
C:000257 e000      	ldi		R16, 0x00
C:000258 9300 007b 	sts		Ticks_L, R16
C:00025a 9300 007c 	sts		Ticks_H, R16
         	
C:00025c e400      	ldi		R16, 0x40					; Disable Comparator interrupt
C:00025d b908      	out		ACSR, R16					; Global interrupt register
         	
C:00025e   +  	Set_SREG_1 	2
C:00025e 9100 007f lds		R16, SREG_1
C:000260 6004      sbr		R16, (1<<2)					

C:000261 9300 007f sts		SREG_1, R16
         			
C:000263 e508      	ldi		R16, 0b01011000				; Enable Comparator interrupt and clear comparator interrupt flag
C:000264 b908      	out		ACSR, R16					; Global interrupt register
         
C:000265 940e 030d 	call Comm_Send_LapTime
C:000267 940e 0322 	call Comm_Send_LapTicks
         
          Lap_Time_End:
         
C:000269   +  	Pop_Register_7 R16, R5, R4, R3, R2, R1, R0
C:000269 910f      pop	R16
C:00026a bf0f      out	SREG, R16
C:00026b 910f      pop	R16
C:00026c 905f      pop	R5
C:00026d 904f      pop	R4
C:00026e 903f      pop	R3
C:00026f 902f      pop	R2
C:000270 901f      pop	R1
C:000271 900f      pop	R0	
         
C:000272 9518      			reti			
          .include "Communication_Protocol.asm"
          .Macro Comm_Init
          	ldi R16, 0x01							;Initialize the counter as being the first byte
          	sts Comm_Received_Byte_Num, R16			;
          	clr R16									;Clear all of the SRAM-values used
          	sts Comm_Received_Byte_1, R16			;
          	sts Comm_Received_Byte_2, R16			;
          	sts Comm_Received_Byte_3, R16			;
          .ENDMACRO
         
         
         ;Define Types
          .equ Comm_Type_Set = 0x55					;Used for setting a value or activating a command
          .equ Comm_Type_Get = 0xAA					;Used for getting a value from the microcontroller
         
         ;Define Set Commands
          .equ Comm_Command_Start = 0x10				;Start the car at a specific % of motor speed
          .equ Comm_Command_Stop = 0x11				;Stop the car
         
         ;Define Get Commands
          .equ Comm_Command_Xaccel_H = 0xA1
          .equ Comm_Command_Xaccel_L = 0xA2
         
          .equ Comm_Command_Zgyro_H = 0xA3
          .equ Comm_Command_ZGyro_L = 0xA4
         
          .equ Comm_Command_Ticks_H = 0xA5
          .equ Comm_Command_Ticks_L = 0xA6
         
          .equ Comm_Command_LapTime_H = 0xA7
          .equ Comm_Command_LapTime_L = 0xA8
         
          .equ Comm_Command_LapTicks_H = 0xA9
          .equ Comm_Command_LapTicks_L = 0xAA
         
          .equ Comm_Command_Data = 0xAB
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Comm Received: Used as a USART Received interrupt
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received:
         
C:000273 9100 0080 	lds R16, Comm_Received_Byte_Num			;What byte # did we receive
         
C:000275 3001      	cpi R16, 0x01							;If it was the first
C:000276 f019      	breq Comm_Received_Type					;Set the type
         
C:000277 3002      	cpi R16, 0x02							;If it was the second
C:000278 f069      	breq Comm_Received_Command				;Set the command
         
         	;Working under the assumption that if it was not the first or second byte, then it must be the third.
         
C:000279 c02c      	rjmp Comm_Received_Execute				;Go to the execution of the received telegram
         
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Received a type
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received_Type:
         	
C:00027a b10c      	in R16, UDR	
         				
          Comm_Received_Type_Set_Check:				;Check if we received a set type
C:00027b 3505      	cpi R16, Comm_Type_Set					;Check for set type
C:00027c f019      	breq Comm_Received_Type_Valid			;Branch to the next check if not the case
         
          Comm_Received_Type_Get_Check:				;Check if we received a get type
C:00027d 3a0a      	cpi R16, Comm_Type_Get					;Check for get type
C:00027e f009      	breq Comm_Received_Type_Valid			;Branch to the reset since we did not received a valid type
         
          Comm_Received_Type_Reset:					;Branch here if it was not a valid type
C:00027f 9518      	reti									;Does nothing else than return since the byte counter is already at one
         
          Comm_Received_Type_Valid:
C:000280 9300 0081 	sts Comm_Received_Byte_1, R16			;Store the received type in SRAM	
C:000282 e002      	ldi R16, 0x02							;Set the counter to two
C:000283 9300 0080 	sts Comm_Received_Byte_Num, R16			;Store it					
C:000285 9518      reti										;Return from interrupt
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Received a command
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received_Command:
         
C:000286 9100 0081 	lds R16, Comm_Received_Byte_1
         
          Comm_Received_Command_Type_Set_Check:				;Check if we received a set type
C:000288 3505      	cpi R16, Comm_Type_Set							;Check for set type
C:000289 f031      	breq Comm_Received_Command_Type_Set				;Branch to the next check if not the case
         
          Comm_Received_Command_Type_Get_Check:				;Check if we received a get type
C:00028a 3a0a      	cpi R16, Comm_Type_Get							;Check for get type
C:00028b f059      	breq Comm_Received_Command_Type_Get				;Branch to the reset since we did not received a valid type
         
          Comm_Received_Command_Failure:						;This should never actually be called, since this is only possible if something else is tangling with the specific SRAM address inbetween bytes
C:00028c e403      	ldi R16, 'C'											;But in the case that this happens
C:00028d 940e 0034 	call USART_Transmit								;The program will be stuck in the interrupt and spam
C:00028f cffc      	rjmp Comm_Received_Command_Failure				;'C' over the USART
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Check for matching set commands
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received_Command_Type_Set:
C:000290 b10c      	in R16, UDR	
         
         ;Start			
          Comm_Received_Command_Start_Check:					;Check if we received a start command
C:000291 3100      	cpi R16, Comm_Command_Start						;Check for start command
C:000292 f069      	breq Comm_Received_Command_Valid		;Branch to the next check if not the case
         
         ;Stop
          Comm_Received_Command_Stop_Check:					;Check if we received a stop command
C:000293 3101      	cpi R16, Comm_Command_Stop						;Check for stop command
C:000294 f059      	breq Comm_Received_Command_Valid				;Branch to the next check if not the case
         
         ;Invalid
C:000295 940c 029c 	jmp Comm_Received_Command_Reset					;If we did not in fact receive a valid set command, then reset
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Check for matching get commands
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received_Command_Type_Get:
C:000297 b10c      	in R16, UDR	
         
         ;Laptime
          Comm_Received_Command_Data_Check:					;Check if we received a LapTime command
C:000298 3a0b      	cpi R16, Comm_Command_Data						;Check for LapTime command
C:000299 f031      	breq Comm_Received_Command_Valid				;Branch to the next check if not the case
         
         ;Invalid
C:00029a 940c 029c 	jmp Comm_Received_Command_Reset					;If we did not in fact receive a valid set command, then reset
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Command handling
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received_Command_Reset:
C:00029c e001      	ldi R16, 0x01									;Reset the byte counter since we received an invalid command after a valid type									
C:00029d 9300 0080 	sts Comm_Received_Byte_Num, R16					;
C:00029f 9518      	reti											;Return
         
          Comm_Received_Command_Valid:						
C:0002a0 9300 0082 	sts Comm_Received_Byte_2, R16					;Store the received type in SRAM	
C:0002a2 e003      	ldi R16, 0x03									;Set the counter to two
C:0002a3 9300 0080 	sts Comm_Received_Byte_Num, R16					;Store it					
C:0002a5 9518      reti												;Return from interrupt
         
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Execute
         ;---------------------------------------------------------------------------------------------------------------------
          Comm_Received_Execute:
         
C:0002a6 b10c      	in r16, UDR								;Read in the received parameter
C:0002a7 9300 0083 	sts Comm_Received_Byte_3, R16			;Store it in SRAM
         	
C:0002a9 e001      	ldi R16, 0x01							;Reset the counter
C:0002aa 9300 0080 	sts Comm_Received_Byte_Num, R16			;Store it in SRAM
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Execute Types
         ;---------------------------------------------------------------------------------------------------------------------
         
C:0002ac 9100 0081 	lds R16, Comm_Received_Byte_1			;Load in the first(Type) byte
         
         	;SET
C:0002ae 3505      	cpi R16, Comm_Type_Set					;Check if we received a SET and branch if it was
C:0002af f019      	breq Comm_Received_Execute_Set			;
         
         	;GET
C:0002b0 3a0a      	cpi R16, Comm_Type_Get					;Check if we received a GET and branch if it was
C:0002b1 f081      	breq Comm_Received_Execute_Get			;
         
C:0002b2 9518      	reti
         ;---------------------------------------------------------------------------------------------------------------------
         ;Execute SET's
         ;---------------------------------------------------------------------------------------------------------------------
         
          Comm_Received_Execute_Set:
         
C:0002b3 9100 0082 	lds R16, Comm_Received_Byte_2			;Load in the second(Command) byte
         
C:0002b5 3100      	cpi R16, Comm_Command_Start				;Check if we received a Start command
C:0002b6 f019      	breq Comm_Received_Execute_Set_Start	;
         
C:0002b7 3101      	cpi R16, Comm_Command_Stop				;Check if we received a Stop command
C:0002b8 f031      	breq Comm_Received_Execute_Set_Stop		;
         
         	;Insert error handling here
         
C:0002b9 9518      	reti									;Do nothing if it was not a legit code
         
         ;Start
          Comm_Received_Execute_Set_Start:
         
C:0002ba 9100 0083 	lds R16, Comm_Received_Byte_3			;Load in the third(Parameter) byte
         
C:0002bc 940e 00fd 	call Motor_Set_Percentage
         
          Comm_Received_Execute_Set_Start_End:
         
C:0002be 9518      	reti									;Return from interrupt
         
         ;Stop
          Comm_Received_Execute_Set_Stop:
         
C:0002bf e000      	ldi R16, 0x00							;Load in 0x00
C:0002c0 bd03      	out OCR2, R16							;And set the pwm duty cycle to nothing to stop the motor.
         
C:0002c1 9518      	reti
         
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Execute GET's
         ;---------------------------------------------------------------------------------------------------------------------
         
          Comm_Received_Execute_Get:	
         
C:0002c2 9100 0082 	lds R16, Comm_Received_Byte_2			;Load in the second(Command) byte
         
C:0002c4 3a0b      	cpi R16, Comm_Command_Data		
C:0002c5 f009      	breq Comm_Received_Execute_Get_Data		
         
         	;Insert error handling here
         
C:0002c6 9518      	reti									;Do nothing if it was not a legit code
         
          Comm_Received_Execute_Get_Data:
C:0002c7 940e 02f8 	call Comm_Received_Execute_Get_Ticks
         	;call Comm_Received_Execute_Get_Zgyro
         	;call Comm_Received_Execute_Get_Xaccel
C:0002c9 9518      	reti
         
          Comm_Received_Execute_Get_Xaccel:
         
C:0002ca 940e 017d 	call MPU6050_Read_Accel_X
         
C:0002cc eb0b      	ldi R16, 0xBB
C:0002cd 940e 0034 	call USART_Transmit
         
C:0002cf ea01      	ldi R16, Comm_Command_Xaccel_H
C:0002d0 940e 0034 	call USART_Transmit
         
C:0002d2 9100 0060 	lds R16, ACCEL_XOUT_H
C:0002d4 940e 0034 	call USART_Transmit
         	
C:0002d6 eb0b      	ldi R16, 0xBB
C:0002d7 940e 0034 	call USART_Transmit
         
C:0002d9 ea02      	ldi R16, Comm_Command_Xaccel_L
C:0002da 940e 0034 	call USART_Transmit
         
C:0002dc 9100 0061 	lds R16, ACCEL_XOUT_L
C:0002de 940e 0034 	call USART_Transmit
         
C:0002e0 9508      	ret
         
          Comm_Received_Execute_Get_Zgyro:
C:0002e1 940e 0197 	call MPU6050_Read_Gyro_Z
         
C:0002e3 eb0b      	ldi R16, 0xBB
C:0002e4 940e 0034 	call USART_Transmit
         
C:0002e6 ea03      	ldi R16, Comm_Command_Zgyro_H
C:0002e7 940e 0034 	call USART_Transmit
         
C:0002e9 9100 006c 	lds R16, GYRO_ZOUT_H
C:0002eb 940e 0034 	call USART_Transmit
         	
C:0002ed eb0b      	ldi R16, 0xBB
C:0002ee 940e 0034 	call USART_Transmit
         
C:0002f0 ea04      	ldi R16, Comm_Command_Zgyro_L
C:0002f1 940e 0034 	call USART_Transmit
         
C:0002f3 9100 006d 	lds R16, GYRO_ZOUT_L
C:0002f5 940e 0034 	call USART_Transmit
         
C:0002f7 9508      	ret
         
          Comm_Received_Execute_Get_Ticks:
         
C:0002f8 eb0b      	ldi R16, 0xBB
C:0002f9 940e 0034 	call USART_Transmit
         
C:0002fb ea05      	ldi R16, Comm_Command_Ticks_H
C:0002fc 940e 0034 	call USART_Transmit
         
C:0002fe 9100 007c 	lds R16, Ticks_H
C:000300 940e 0034 	call USART_Transmit
         	
C:000302 eb0b      	ldi R16, 0xBB
C:000303 940e 0034 	call USART_Transmit
         
C:000305 ea06      	ldi R16, Comm_Command_Ticks_L
C:000306 940e 0034 	call USART_Transmit
         
C:000308 9100 007b 	lds R16, Ticks_L
C:00030a 940e 0034 	call USART_Transmit
         
C:00030c 9508      	ret
         
         ;---------------------------------------------------------------------------------------------------------------------
         ;Send
         ;---------------------------------------------------------------------------------------------------------------------
         
         ;LapTime
          Comm_Send_LapTime:
C:00030d eb0b      	ldi R16, 0xBB
C:00030e 940e 0034 	call USART_Transmit
         
C:000310 ea07      	ldi R16, Comm_Command_LapTime_H
C:000311 940e 0034 	call USART_Transmit
         
C:000313 9100 0075 	lds R16, Lap_time_M
C:000315 940e 0034 	call USART_Transmit
         	
C:000317 eb0b      	ldi R16, 0xBB
C:000318 940e 0034 	call USART_Transmit
         
C:00031a ea08      	ldi R16, Comm_Command_LapTime_L
C:00031b 940e 0034 	call USART_Transmit
         
C:00031d 9100 0074 	lds R16, Lap_time_L
C:00031f 940e 0034 	call USART_Transmit
         
C:000321 9508      	ret
         
         ;Lap ticks
          Comm_Send_LapTicks:
C:000322 eb0b      	ldi R16, 0xBB
C:000323 940e 0034 	call USART_Transmit
         
C:000325 ea09      	ldi R16, Comm_Command_LapTicks_H
C:000326 940e 0034 	call USART_Transmit
         
C:000328 9100 007e 	lds R16, Ticks_Lap_H
C:00032a 940e 0034 	call USART_Transmit
         	
C:00032c eb0b      	ldi R16, 0xBB
C:00032d 940e 0034 	call USART_Transmit
         
C:00032f ea0a      	ldi R16, Comm_Command_LapTicks_L
C:000330 940e 0034 	call USART_Transmit
         
C:000332 9100 007d 	lds R16, Ticks_Lap_L
C:000334 940e 0034 	call USART_Transmit
         
C:000336 9508      	ret
          .include "Setup.asm"
          .MACRO Setup
         	;Initialize the stack
          	LDI	R16, low(RAMEND)
              OUT	SPL, R16
          	LDI	R16, high(RAMEND)
              OUT	SPH, R16			
          
          	USART_Init 0b00000000,0b01100111	;Initialize the USART module with 9600 baud @ 16MHz clock
          	Comm_Init							;Intialize the communication protocol
          	Motor_Init							;Initialize the motor pwm
          	Brake_Init							;Initialize the brake pin
          	I2C_Init 0x00,0x12					;Initialize the TWI module with Prescaler 4 and TWBR 12
          	Time_Init							;Initialize the timer associated with timekeeping
          	WheelSpeed_Init						;Initialize the wheel speed sensor
          	LapCounter_Init						;Initialize the lap counter
          	MPU6050_Init						;Initialize the MPU6050 3 times to make sure it writes the values(We should make some kind of check instead)
          	MPU6050_Init						;
          	MPU6050_Init						;
          	
          
         	;Global interrupt
          	
          .ENDMACRO
         
          Init:
C:000337   +  	Setup
         

C:000337 e50f      LDI	R16, low(RAMEND)
C:000338 bf0d      OUT	SPL, R16
C:000339 e008      LDI	R16, high(RAMEND)
C:00033a bf0e      OUT	SPH, R16			
         
C:00033b   +  USART_Init 0b00000000,0b01100111	

         

C:00033b e607      ldi R16,	0b01100111	
C:00033c e010      ldi R17,	0b00000000
         
C:00033d bd10      out	UBRRH,	R17
C:00033e b909      out UBRRL,	R16
         
         

C:00033f e908      ldi R16,	(1<<RXEN)|(1<<TXEN)|(1<<RXCIE)
C:000340 b90a      out	UCSRB,	R16
         
         

C:000341 e806      ldi	R16,	(1<<URSEL)|(3<<UCSZ0)
C:000342 bd00      out	UCSRC,	R16
C:000343   +  Comm_Init							

C:000343 e001      ldi R16, 0x01							

C:000344 9300 0080 sts Comm_Received_Byte_Num, R16			

C:000346 2700      clr R16									

C:000347 9300 0081 sts Comm_Received_Byte_1, R16			

C:000349 9300 0082 sts Comm_Received_Byte_2, R16			

C:00034b 9300 0083 sts Comm_Received_Byte_3, R16			

C:00034d   +  Motor_Init							

C:00034d b301      in R16, DDRD							

C:00034e 6800      ori R16, (1<<PD7)						

C:00034f bb01      out DDRD, R16
         
C:000350 e609      ldi R16, 0b01101001						

C:000351 bd05      out TCCR2, R16							

C:000352   +  Brake_Init							

         
C:000352 b307      in R16, DDRB							

C:000353 6001      ori R16, (1<<BRAKE_PIN)					

C:000354 bb07      out DDRB, R16							

         
C:000355 98c0      cbi	PORTB, BRAKE_PIN					

         
         
C:000356   +  I2C_Init 0x00,0x12					

         

C:000356 e000      ldi R16, 0x00
C:000357 b901      out TWSR, R16
         
         

C:000358 e102      ldi R16, 0x12
C:000359 b900      out TWBR, R16
         
         

C:00035a e004      ldi R16, (1<<TWEN)
C:00035b bf06      out TWCR, R16
         
C:00035c 0000      nop 

         
         
C:00035d   +  Time_Init							

C:00035d e00b      ldi		R16, 0b00001011			

C:00035e bf03      out		TCCR0, R16
C:00035f e000      ldi		R16, 0x00
C:000360 bf02      out		TCNT0, R16				

C:000361 ef09      ldi		R16, 249				

C:000362 bf0c      out		OCR0, R16
         
C:000363 2700      clr		R16
C:000364 9300 0070 sts		Timer_1ms_L, R16
C:000366 9300 006f sts		Timer_1ms_M, R16
C:000368 9300 006e sts		Timer_1ms_H, R16	
         
C:00036a b709      in		R16, TIMSK
C:00036b 6002      ori		R16, (1<<OCIE0)			

C:00036c bf09      out		TIMSK, R16				

         
         
C:00036d   +  WheelSpeed_Init						

         
         
         
C:00036d e000      ldi		R16, 0x00
C:00036e bd0f      out		TCCR1A, R16
C:00036f e002      ldi		R16, 0b00000010			

C:000370 bd0e      out		TCCR1B, R16	
         
C:000371 2700      clr		R16
C:000372 9300 0077 sts		Edge1_L, R16
C:000374 9300 0078 sts		Edge1_H, R16
         
C:000376 9300 007b sts		Ticks_L, R16
C:000378 9300 007c sts		Ticks_H, R16
         
C:00037a b709      in		R16, TIMSK
C:00037b 6200      ori		R16, (1<<TICIE1)		

C:00037c bf09      out		TIMSK, R16				

         
         
C:00037d   +  LapCounter_Init						

         
C:00037d 2700      clr	R16
C:00037e 9300 0073 sts	Time_Stamp_L, R16
C:000380 9300 0072 sts	Time_Stamp_M, R16
C:000382 9300 0071 sts	Time_Stamp_H, R16
         
C:000384 9300 0074 sts	Lap_time_L, R16
C:000386 9300 0075 sts	Lap_time_M, R16
C:000388 9300 0076 sts	Lap_time_H, R16
         
C:00038a b108      in R16, ACSR
C:00038b 6408      ori R16, 0x48						

C:00038c b908      out ACSR, R16						

         
C:00038d b700      in R16, SFIOR						

C:00038e 7f07      andi R16, ~(1<<ACME)				

C:00038f bf00      out SFIOR, R16						

         
C:000390 98bb      cbi DDRB,PB3						

         
         
C:000391   +  MPU6050_Init						

         
C:000391 940e 010c call I2C_Start							

C:000393   +  I2C_Write MPU6050_ADDRESS_W				

C:000393 ed00      ldi R16, MPU6050_ADDRESS_W
C:000394 940e 0115 call I2C_Write_Call
         
C:000396   +  I2C_Write MPU6050_RA_SMPLRT_DIV			

C:000396 e109      ldi R16, MPU6050_RA_SMPLRT_DIV
C:000397 940e 0115 call I2C_Write_Call
         
         

C:000399   +  I2C_Write 0x07
C:000399 e007      ldi R16, 0x07
C:00039a 940e 0115 call I2C_Write_Call
         
         

C:00039c   +  I2C_Write 0x00
C:00039c e000      ldi R16, 0x00
C:00039d 940e 0115 call I2C_Write_Call
         
         

C:00039f   +  I2C_Write 0b00001000
C:00039f e008      ldi R16, 0b00001000
C:0003a0 940e 0115 call I2C_Write_Call
         
         

C:0003a2   +  I2C_Write 0b00001000
C:0003a2 e008      ldi R16, 0b00001000
C:0003a3 940e 0115 call I2C_Write_Call
         
         

C:0003a5   +  I2C_Write 0x00
C:0003a5 e000      ldi R16, 0x00
C:0003a6 940e 0115 call I2C_Write_Call
         
         

C:0003a8   +  I2C_Write 0x00
C:0003a8 e000      ldi R16, 0x00
C:0003a9 940e 0115 call I2C_Write_Call
         
         

C:0003ab   +  I2C_Write 0x00
C:0003ab e000      ldi R16, 0x00
C:0003ac 940e 0115 call I2C_Write_Call
         
         

C:0003ae   +  I2C_Write 0x00
C:0003ae e000      ldi R16, 0x00
C:0003af 940e 0115 call I2C_Write_Call
         
         

C:0003b1   +  I2C_Write 0x00
C:0003b1 e000      ldi R16, 0x00
C:0003b2 940e 0115 call I2C_Write_Call
         
         

C:0003b4   +  I2C_Write 0x00
C:0003b4 e000      ldi R16, 0x00
C:0003b5 940e 0115 call I2C_Write_Call
         
         

C:0003b7   +  I2C_Write 0x00
C:0003b7 e000      ldi R16, 0x00
C:0003b8 940e 0115 call I2C_Write_Call
         
         

         

C:0003ba   +  I2C_Write 0x00
C:0003ba e000      ldi R16, 0x00
C:0003bb 940e 0115 call I2C_Write_Call
         
         

         

C:0003bd   +  I2C_Write 0x00
C:0003bd e000      ldi R16, 0x00
C:0003be 940e 0115 call I2C_Write_Call
         
         

C:0003c0   +  I2C_Write 0x00
C:0003c0 e000      ldi R16, 0x00
C:0003c1 940e 0115 call I2C_Write_Call
         
         

C:0003c3   +  I2C_Write 0x00
C:0003c3 e000      ldi R16, 0x00
C:0003c4 940e 0115 call I2C_Write_Call
         
         

C:0003c6   +  I2C_Write 0x00
C:0003c6 e000      ldi R16, 0x00
C:0003c7 940e 0115 call I2C_Write_Call
         
         

C:0003c9   +  I2C_Write 0x00
C:0003c9 e000      ldi R16, 0x00
C:0003ca 940e 0115 call I2C_Write_Call
         
         

C:0003cc   +  I2C_Write 0x00
C:0003cc e000      ldi R16, 0x00
C:0003cd 940e 0115 call I2C_Write_Call
         
         

C:0003cf   +  I2C_Write 0x00
C:0003cf e000      ldi R16, 0x00
C:0003d0 940e 0115 call I2C_Write_Call
         
         

C:0003d2   +  I2C_Write 0x00
C:0003d2 e000      ldi R16, 0x00
C:0003d3 940e 0115 call I2C_Write_Call
         
         

C:0003d5   +  I2C_Write 0x00
C:0003d5 e000      ldi R16, 0x00
C:0003d6 940e 0115 call I2C_Write_Call
         
         

C:0003d8   +  I2C_Write 0x00
C:0003d8 e000      ldi R16, 0x00
C:0003d9 940e 0115 call I2C_Write_Call
         
         

C:0003db   +  I2C_Write 0x00
C:0003db e000      ldi R16, 0x00
C:0003dc 940e 0115 call I2C_Write_Call
         
         

C:0003de   +  I2C_Write 0x00
C:0003de e000      ldi R16, 0x00
C:0003df 940e 0115 call I2C_Write_Call
         
         

C:0003e1   +  I2C_Write 0x00
C:0003e1 e000      ldi R16, 0x00
C:0003e2 940e 0115 call I2C_Write_Call
         
         

C:0003e4   +  I2C_Write 0x00
C:0003e4 e000      ldi R16, 0x00
C:0003e5 940e 0115 call I2C_Write_Call
         
         

C:0003e7   +  I2C_Write 0x00
C:0003e7 e000      ldi R16, 0x00
C:0003e8 940e 0115 call I2C_Write_Call
         
         

C:0003ea   +  I2C_Write 0x00
C:0003ea e000      ldi R16, 0x00
C:0003eb 940e 0115 call I2C_Write_Call
         
         

C:0003ed   +  I2C_Write 0x00
C:0003ed e000      ldi R16, 0x00
C:0003ee 940e 0115 call I2C_Write_Call
         
         

         
         

C:0003f0 940e 010c call I2C_Start							

C:0003f2   +  I2C_Write MPU6050_ADDRESS_W				

C:0003f2 ed00      ldi R16, MPU6050_ADDRESS_W
C:0003f3 940e 0115 call I2C_Write_Call
         
C:0003f5   +  I2C_Write MPU6050_RA_INT_PIN_CFG		

C:0003f5 e307      ldi R16, MPU6050_RA_INT_PIN_CFG
C:0003f6 940e 0115 call I2C_Write_Call
C:0003f8   +  I2C_Write 0x00							

C:0003f8 e000      ldi R16, 0x00
C:0003f9 940e 0115 call I2C_Write_Call
         
         

C:0003fb   +  I2C_Write 0x00
C:0003fb e000      ldi R16, 0x00
C:0003fc 940e 0115 call I2C_Write_Call
         
         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         
         

         
         

C:0003fe 940e 010c call I2C_Start							

C:000400   +  I2C_Write MPU6050_ADDRESS_W				

C:000400 ed00      ldi R16, MPU6050_ADDRESS_W
C:000401 940e 0115 call I2C_Write_Call
         
C:000403   +  I2C_Write MPU6050_RA_I2C_SLV0_DO		

C:000403 e603      ldi R16, MPU6050_RA_I2C_SLV0_DO
C:000404 940e 0115 call I2C_Write_Call
C:000406   +  I2C_Write 0x00							

C:000406 e000      ldi R16, 0x00
C:000407 940e 0115 call I2C_Write_Call
         
         

C:000409   +  I2C_Write 0x00
C:000409 e000      ldi R16, 0x00
C:00040a 940e 0115 call I2C_Write_Call
         
         

C:00040c   +  I2C_Write 0x00
C:00040c e000      ldi R16, 0x00
C:00040d 940e 0115 call I2C_Write_Call
         
         

C:00040f   +  I2C_Write 0x00
C:00040f e000      ldi R16, 0x00
C:000410 940e 0115 call I2C_Write_Call
         
         

C:000412   +  I2C_Write 0x00
C:000412 e000      ldi R16, 0x00
C:000413 940e 0115 call I2C_Write_Call
         
         

C:000415   +  I2C_Write 0x00
C:000415 e000      ldi R16, 0x00
C:000416 940e 0115 call I2C_Write_Call
         
         

C:000418   +  I2C_Write 0x00
C:000418 e000      ldi R16, 0x00
C:000419 940e 0115 call I2C_Write_Call
         
         

C:00041b   +  I2C_Write 0x00
C:00041b e000      ldi R16, 0x00
C:00041c 940e 0115 call I2C_Write_Call
         
         

C:00041e   +  I2C_Write 0b00000010
C:00041e e002      ldi R16, 0b00000010
C:00041f 940e 0115 call I2C_Write_Call
         
         

C:000421   +  I2C_Write 0x00
C:000421 e000      ldi R16, 0x00
C:000422 940e 0115 call I2C_Write_Call
         
         

         

         

         

         

         

         

         
         

C:000424 940e 010c call I2C_Start							

C:000426   +  I2C_Write MPU6050_ADDRESS_W				

C:000426 ed00      ldi R16, MPU6050_ADDRESS_W
C:000427 940e 0115 call I2C_Write_Call
         
C:000429   +  I2C_Write MPU6050_RA_FIFO_R_W			

C:000429 e704      ldi R16, MPU6050_RA_FIFO_R_W
C:00042a 940e 0115 call I2C_Write_Call
C:00042c   +  I2C_Write 0x00							

C:00042c e000      ldi R16, 0x00
C:00042d 940e 0115 call I2C_Write_Call
         
         

         
C:00042f 940e 0112 call I2C_Stop							

C:000431   +  MPU6050_Init						

         
C:000431 940e 010c call I2C_Start							

C:000433   +  I2C_Write MPU6050_ADDRESS_W				

C:000433 ed00      ldi R16, MPU6050_ADDRESS_W
C:000434 940e 0115 call I2C_Write_Call
         
C:000436   +  I2C_Write MPU6050_RA_SMPLRT_DIV			

C:000436 e109      ldi R16, MPU6050_RA_SMPLRT_DIV
C:000437 940e 0115 call I2C_Write_Call
         
         

C:000439   +  I2C_Write 0x07
C:000439 e007      ldi R16, 0x07
C:00043a 940e 0115 call I2C_Write_Call
         
         

C:00043c   +  I2C_Write 0x00
C:00043c e000      ldi R16, 0x00
C:00043d 940e 0115 call I2C_Write_Call
         
         

C:00043f   +  I2C_Write 0b00001000
C:00043f e008      ldi R16, 0b00001000
C:000440 940e 0115 call I2C_Write_Call
         
         

C:000442   +  I2C_Write 0b00001000
C:000442 e008      ldi R16, 0b00001000
C:000443 940e 0115 call I2C_Write_Call
         
         

C:000445   +  I2C_Write 0x00
C:000445 e000      ldi R16, 0x00
C:000446 940e 0115 call I2C_Write_Call
         
         

C:000448   +  I2C_Write 0x00
C:000448 e000      ldi R16, 0x00
C:000449 940e 0115 call I2C_Write_Call
         
         

C:00044b   +  I2C_Write 0x00
C:00044b e000      ldi R16, 0x00
C:00044c 940e 0115 call I2C_Write_Call
         
         

C:00044e   +  I2C_Write 0x00
C:00044e e000      ldi R16, 0x00
C:00044f 940e 0115 call I2C_Write_Call
         
         

C:000451   +  I2C_Write 0x00
C:000451 e000      ldi R16, 0x00
C:000452 940e 0115 call I2C_Write_Call
         
         

C:000454   +  I2C_Write 0x00
C:000454 e000      ldi R16, 0x00
C:000455 940e 0115 call I2C_Write_Call
         
         

C:000457   +  I2C_Write 0x00
C:000457 e000      ldi R16, 0x00
C:000458 940e 0115 call I2C_Write_Call
         
         

         

C:00045a   +  I2C_Write 0x00
C:00045a e000      ldi R16, 0x00
C:00045b 940e 0115 call I2C_Write_Call
         
         

         

C:00045d   +  I2C_Write 0x00
C:00045d e000      ldi R16, 0x00
C:00045e 940e 0115 call I2C_Write_Call
         
         

C:000460   +  I2C_Write 0x00
C:000460 e000      ldi R16, 0x00
C:000461 940e 0115 call I2C_Write_Call
         
         

C:000463   +  I2C_Write 0x00
C:000463 e000      ldi R16, 0x00
C:000464 940e 0115 call I2C_Write_Call
         
         

C:000466   +  I2C_Write 0x00
C:000466 e000      ldi R16, 0x00
C:000467 940e 0115 call I2C_Write_Call
         
         

C:000469   +  I2C_Write 0x00
C:000469 e000      ldi R16, 0x00
C:00046a 940e 0115 call I2C_Write_Call
         
         

C:00046c   +  I2C_Write 0x00
C:00046c e000      ldi R16, 0x00
C:00046d 940e 0115 call I2C_Write_Call
         
         

C:00046f   +  I2C_Write 0x00
C:00046f e000      ldi R16, 0x00
C:000470 940e 0115 call I2C_Write_Call
         
         

C:000472   +  I2C_Write 0x00
C:000472 e000      ldi R16, 0x00
C:000473 940e 0115 call I2C_Write_Call
         
         

C:000475   +  I2C_Write 0x00
C:000475 e000      ldi R16, 0x00
C:000476 940e 0115 call I2C_Write_Call
         
         

C:000478   +  I2C_Write 0x00
C:000478 e000      ldi R16, 0x00
C:000479 940e 0115 call I2C_Write_Call
         
         

C:00047b   +  I2C_Write 0x00
C:00047b e000      ldi R16, 0x00
C:00047c 940e 0115 call I2C_Write_Call
         
         

C:00047e   +  I2C_Write 0x00
C:00047e e000      ldi R16, 0x00
C:00047f 940e 0115 call I2C_Write_Call
         
         

C:000481   +  I2C_Write 0x00
C:000481 e000      ldi R16, 0x00
C:000482 940e 0115 call I2C_Write_Call
         
         

C:000484   +  I2C_Write 0x00
C:000484 e000      ldi R16, 0x00
C:000485 940e 0115 call I2C_Write_Call
         
         

C:000487   +  I2C_Write 0x00
C:000487 e000      ldi R16, 0x00
C:000488 940e 0115 call I2C_Write_Call
         
         

C:00048a   +  I2C_Write 0x00
C:00048a e000      ldi R16, 0x00
C:00048b 940e 0115 call I2C_Write_Call
         
         

C:00048d   +  I2C_Write 0x00
C:00048d e000      ldi R16, 0x00
C:00048e 940e 0115 call I2C_Write_Call
         
         

         
         

C:000490 940e 010c call I2C_Start							

C:000492   +  I2C_Write MPU6050_ADDRESS_W				

C:000492 ed00      ldi R16, MPU6050_ADDRESS_W
C:000493 940e 0115 call I2C_Write_Call
         
C:000495   +  I2C_Write MPU6050_RA_INT_PIN_CFG		

C:000495 e307      ldi R16, MPU6050_RA_INT_PIN_CFG
C:000496 940e 0115 call I2C_Write_Call
C:000498   +  I2C_Write 0x00							

C:000498 e000      ldi R16, 0x00
C:000499 940e 0115 call I2C_Write_Call
         
         

C:00049b   +  I2C_Write 0x00
C:00049b e000      ldi R16, 0x00
C:00049c 940e 0115 call I2C_Write_Call
         
         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         
         

         
         

C:00049e 940e 010c call I2C_Start							

C:0004a0   +  I2C_Write MPU6050_ADDRESS_W				

C:0004a0 ed00      ldi R16, MPU6050_ADDRESS_W
C:0004a1 940e 0115 call I2C_Write_Call
         
C:0004a3   +  I2C_Write MPU6050_RA_I2C_SLV0_DO		

C:0004a3 e603      ldi R16, MPU6050_RA_I2C_SLV0_DO
C:0004a4 940e 0115 call I2C_Write_Call
C:0004a6   +  I2C_Write 0x00							

C:0004a6 e000      ldi R16, 0x00
C:0004a7 940e 0115 call I2C_Write_Call
         
         

C:0004a9   +  I2C_Write 0x00
C:0004a9 e000      ldi R16, 0x00
C:0004aa 940e 0115 call I2C_Write_Call
         
         

C:0004ac   +  I2C_Write 0x00
C:0004ac e000      ldi R16, 0x00
C:0004ad 940e 0115 call I2C_Write_Call
         
         

C:0004af   +  I2C_Write 0x00
C:0004af e000      ldi R16, 0x00
C:0004b0 940e 0115 call I2C_Write_Call
         
         

C:0004b2   +  I2C_Write 0x00
C:0004b2 e000      ldi R16, 0x00
C:0004b3 940e 0115 call I2C_Write_Call
         
         

C:0004b5   +  I2C_Write 0x00
C:0004b5 e000      ldi R16, 0x00
C:0004b6 940e 0115 call I2C_Write_Call
         
         

C:0004b8   +  I2C_Write 0x00
C:0004b8 e000      ldi R16, 0x00
C:0004b9 940e 0115 call I2C_Write_Call
         
         

C:0004bb   +  I2C_Write 0x00
C:0004bb e000      ldi R16, 0x00
C:0004bc 940e 0115 call I2C_Write_Call
         
         

C:0004be   +  I2C_Write 0b00000010
C:0004be e002      ldi R16, 0b00000010
C:0004bf 940e 0115 call I2C_Write_Call
         
         

C:0004c1   +  I2C_Write 0x00
C:0004c1 e000      ldi R16, 0x00
C:0004c2 940e 0115 call I2C_Write_Call
         
         

         

         

         

         

         

         

         
         

C:0004c4 940e 010c call I2C_Start							

C:0004c6   +  I2C_Write MPU6050_ADDRESS_W				

C:0004c6 ed00      ldi R16, MPU6050_ADDRESS_W
C:0004c7 940e 0115 call I2C_Write_Call
         
C:0004c9   +  I2C_Write MPU6050_RA_FIFO_R_W			

C:0004c9 e704      ldi R16, MPU6050_RA_FIFO_R_W
C:0004ca 940e 0115 call I2C_Write_Call
C:0004cc   +  I2C_Write 0x00							

C:0004cc e000      ldi R16, 0x00
C:0004cd 940e 0115 call I2C_Write_Call
         
         

         
C:0004cf 940e 0112 call I2C_Stop							

C:0004d1   +  MPU6050_Init						

         
C:0004d1 940e 010c call I2C_Start							

C:0004d3   +  I2C_Write MPU6050_ADDRESS_W				

C:0004d3 ed00      ldi R16, MPU6050_ADDRESS_W
C:0004d4 940e 0115 call I2C_Write_Call
         
C:0004d6   +  I2C_Write MPU6050_RA_SMPLRT_DIV			

C:0004d6 e109      ldi R16, MPU6050_RA_SMPLRT_DIV
C:0004d7 940e 0115 call I2C_Write_Call
         
         

C:0004d9   +  I2C_Write 0x07
C:0004d9 e007      ldi R16, 0x07
C:0004da 940e 0115 call I2C_Write_Call
         
         

C:0004dc   +  I2C_Write 0x00
C:0004dc e000      ldi R16, 0x00
C:0004dd 940e 0115 call I2C_Write_Call
         
         

C:0004df   +  I2C_Write 0b00001000
C:0004df e008      ldi R16, 0b00001000
C:0004e0 940e 0115 call I2C_Write_Call
         
         

C:0004e2   +  I2C_Write 0b00001000
C:0004e2 e008      ldi R16, 0b00001000
C:0004e3 940e 0115 call I2C_Write_Call
         
         

C:0004e5   +  I2C_Write 0x00
C:0004e5 e000      ldi R16, 0x00
C:0004e6 940e 0115 call I2C_Write_Call
         
         

C:0004e8   +  I2C_Write 0x00
C:0004e8 e000      ldi R16, 0x00
C:0004e9 940e 0115 call I2C_Write_Call
         
         

C:0004eb   +  I2C_Write 0x00
C:0004eb e000      ldi R16, 0x00
C:0004ec 940e 0115 call I2C_Write_Call
         
         

C:0004ee   +  I2C_Write 0x00
C:0004ee e000      ldi R16, 0x00
C:0004ef 940e 0115 call I2C_Write_Call
         
         

C:0004f1   +  I2C_Write 0x00
C:0004f1 e000      ldi R16, 0x00
C:0004f2 940e 0115 call I2C_Write_Call
         
         

C:0004f4   +  I2C_Write 0x00
C:0004f4 e000      ldi R16, 0x00
C:0004f5 940e 0115 call I2C_Write_Call
         
         

C:0004f7   +  I2C_Write 0x00
C:0004f7 e000      ldi R16, 0x00
C:0004f8 940e 0115 call I2C_Write_Call
         
         

         

C:0004fa   +  I2C_Write 0x00
C:0004fa e000      ldi R16, 0x00
C:0004fb 940e 0115 call I2C_Write_Call
         
         

         

C:0004fd   +  I2C_Write 0x00
C:0004fd e000      ldi R16, 0x00
C:0004fe 940e 0115 call I2C_Write_Call
         
         

C:000500   +  I2C_Write 0x00
C:000500 e000      ldi R16, 0x00
C:000501 940e 0115 call I2C_Write_Call
         
         

C:000503   +  I2C_Write 0x00
C:000503 e000      ldi R16, 0x00
C:000504 940e 0115 call I2C_Write_Call
         
         

C:000506   +  I2C_Write 0x00
C:000506 e000      ldi R16, 0x00
C:000507 940e 0115 call I2C_Write_Call
         
         

C:000509   +  I2C_Write 0x00
C:000509 e000      ldi R16, 0x00
C:00050a 940e 0115 call I2C_Write_Call
         
         

C:00050c   +  I2C_Write 0x00
C:00050c e000      ldi R16, 0x00
C:00050d 940e 0115 call I2C_Write_Call
         
         

C:00050f   +  I2C_Write 0x00
C:00050f e000      ldi R16, 0x00
C:000510 940e 0115 call I2C_Write_Call
         
         

C:000512   +  I2C_Write 0x00
C:000512 e000      ldi R16, 0x00
C:000513 940e 0115 call I2C_Write_Call
         
         

C:000515   +  I2C_Write 0x00
C:000515 e000      ldi R16, 0x00
C:000516 940e 0115 call I2C_Write_Call
         
         

C:000518   +  I2C_Write 0x00
C:000518 e000      ldi R16, 0x00
C:000519 940e 0115 call I2C_Write_Call
         
         

C:00051b   +  I2C_Write 0x00
C:00051b e000      ldi R16, 0x00
C:00051c 940e 0115 call I2C_Write_Call
         
         

C:00051e   +  I2C_Write 0x00
C:00051e e000      ldi R16, 0x00
C:00051f 940e 0115 call I2C_Write_Call
         
         

C:000521   +  I2C_Write 0x00
C:000521 e000      ldi R16, 0x00
C:000522 940e 0115 call I2C_Write_Call
         
         

C:000524   +  I2C_Write 0x00
C:000524 e000      ldi R16, 0x00
C:000525 940e 0115 call I2C_Write_Call
         
         

C:000527   +  I2C_Write 0x00
C:000527 e000      ldi R16, 0x00
C:000528 940e 0115 call I2C_Write_Call
         
         

C:00052a   +  I2C_Write 0x00
C:00052a e000      ldi R16, 0x00
C:00052b 940e 0115 call I2C_Write_Call
         
         

C:00052d   +  I2C_Write 0x00
C:00052d e000      ldi R16, 0x00
C:00052e 940e 0115 call I2C_Write_Call
         
         

         
         

C:000530 940e 010c call I2C_Start							

C:000532   +  I2C_Write MPU6050_ADDRESS_W				

C:000532 ed00      ldi R16, MPU6050_ADDRESS_W
C:000533 940e 0115 call I2C_Write_Call
         
C:000535   +  I2C_Write MPU6050_RA_INT_PIN_CFG		

C:000535 e307      ldi R16, MPU6050_RA_INT_PIN_CFG
C:000536 940e 0115 call I2C_Write_Call
C:000538   +  I2C_Write 0x00							

C:000538 e000      ldi R16, 0x00
C:000539 940e 0115 call I2C_Write_Call
         
         

C:00053b   +  I2C_Write 0x00
C:00053b e000      ldi R16, 0x00
C:00053c 940e 0115 call I2C_Write_Call
         
         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         
         

         
         

C:00053e 940e 010c call I2C_Start							

C:000540   +  I2C_Write MPU6050_ADDRESS_W				

C:000540 ed00      ldi R16, MPU6050_ADDRESS_W
C:000541 940e 0115 call I2C_Write_Call
         
C:000543   +  I2C_Write MPU6050_RA_I2C_SLV0_DO		

C:000543 e603      ldi R16, MPU6050_RA_I2C_SLV0_DO
C:000544 940e 0115 call I2C_Write_Call
C:000546   +  I2C_Write 0x00							

C:000546 e000      ldi R16, 0x00
C:000547 940e 0115 call I2C_Write_Call
         
         

C:000549   +  I2C_Write 0x00
C:000549 e000      ldi R16, 0x00
C:00054a 940e 0115 call I2C_Write_Call
         
         

C:00054c   +  I2C_Write 0x00
C:00054c e000      ldi R16, 0x00
C:00054d 940e 0115 call I2C_Write_Call
         
         

C:00054f   +  I2C_Write 0x00
C:00054f e000      ldi R16, 0x00
C:000550 940e 0115 call I2C_Write_Call
         
         

C:000552   +  I2C_Write 0x00
C:000552 e000      ldi R16, 0x00
C:000553 940e 0115 call I2C_Write_Call
         
         

C:000555   +  I2C_Write 0x00
C:000555 e000      ldi R16, 0x00
C:000556 940e 0115 call I2C_Write_Call
         
         

C:000558   +  I2C_Write 0x00
C:000558 e000      ldi R16, 0x00
C:000559 940e 0115 call I2C_Write_Call
         
         

C:00055b   +  I2C_Write 0x00
C:00055b e000      ldi R16, 0x00
C:00055c 940e 0115 call I2C_Write_Call
         
         

C:00055e   +  I2C_Write 0b00000010
C:00055e e002      ldi R16, 0b00000010
C:00055f 940e 0115 call I2C_Write_Call
         
         

C:000561   +  I2C_Write 0x00
C:000561 e000      ldi R16, 0x00
C:000562 940e 0115 call I2C_Write_Call
         
         

         

         

         

         

         

         

         
         

C:000564 940e 010c call I2C_Start							

C:000566   +  I2C_Write MPU6050_ADDRESS_W				

C:000566 ed00      ldi R16, MPU6050_ADDRESS_W
C:000567 940e 0115 call I2C_Write_Call
         
C:000569   +  I2C_Write MPU6050_RA_FIFO_R_W			

C:000569 e704      ldi R16, MPU6050_RA_FIFO_R_W
C:00056a 940e 0115 call I2C_Write_Call
C:00056c   +  I2C_Write 0x00							

C:00056c e000      ldi R16, 0x00
C:00056d 940e 0115 call I2C_Write_Call
         
         

         
C:00056f 940e 0112 call I2C_Stop							

         
         
         

         
         
         	
C:000571 ef0a      			ldi		R16, 250
C:000572 940e 00e5 			call	Delay_MS
C:000574 ef0a      			ldi		R16, 250
C:000575 940e 00e5 			call	Delay_MS
C:000577 ef0a      			ldi		R16, 250
C:000578 940e 00e5 			call	Delay_MS
C:00057a ef0a      			ldi		R16, 250
C:00057b 940e 00e5 			call	Delay_MS
C:00057d ef0a      			ldi		R16, 250
C:00057e 940e 00e5 			call	Delay_MS
C:000580 ef0a      			ldi		R16, 250
C:000581 940e 00e5 			call	Delay_MS
C:000583 ef0a      			ldi		R16, 250
C:000584 940e 00e5 			call	Delay_MS
C:000586 ef0a      			ldi		R16, 250
C:000587 940e 00e5 			call	Delay_MS
         			
C:000589 e500      	ldi	R16, 80
C:00058a bd03      	out 	OCR2, R16
C:00058b 2700      	clr		R16					
C:00058c 9300 007f 	sts		SREG_1, R16				; clear SREG_1
         
C:00058e 9478      	sei					;Enable global interrupt	
C:00058f c000      	rjmp Main
         
          Main:	
C:000590 9100 007f 			lds		R16, SREG_1			
         			;sbrc	R16, 2							; bit 0 represents the current edge that's being measured - 0 = EDGE1, 1 = EDGE2
         			;rjmp	Brake
         			
C:000592 cffd      			rjmp	Main
C:000593 9ac0      			sbi		PORTB, 0
         			
         						
C:000594 ef0a      			ldi		R16, 250
C:000595 940e 00e5 			call	Delay_MS
C:000597 ef0a      			ldi		R16, 250
C:000598 940e 00e5 			call	Delay_MS
         			
C:00059a 98c0      			cbi		PORTB, 0
         			
C:00059b ef0a      			ldi		R16, 250
C:00059c 940e 00e5 			call	Delay_MS
C:00059e ef0a      			ldi		R16, 250
C:00059f 940e 00e5 			call	Delay_MS	
         			
C:0005a1 cfee      			rjmp	Main
         			
C:0005a2 cfed      			rjmp	Main
         	
         	
C:0005a3 2700      Brake: 		clr		R16
C:0005a4 bd03      			out		OCR2, R16
         			
C:0005a5 988f      			cbi		DDRD, 7							; set motor pin as input
         	
C:0005a6 0000      			nop
         			
C:0005a7 9ac0      			sbi		PORTB, 0
         			
C:0005a8 94f8      			cli
C:0005a9 ef0a      			ldi		R16, 250
C:0005aa 940e 00e5 			call	Delay_MS
C:0005ac ef0a      			ldi		R16, 250
C:0005ad 940e 00e5 			call	Delay_MS
C:0005af ec08      			ldi		R16, 200
         			;call	Delay_MS
         			
C:0005b0 98c0      			cbi		PORTB, 0
         			
C:0005b1 cfff      Wait:		rjmp	Wait
         
         			
          Brake2:		;rjmp	Brake
         
C:0005b2 9a8f      			sbi		DDRD, 7
C:0005b3 0000      			nop
C:0005b4 0000      			nop
         			
C:0005b5 e500      			ldi		R16, 80
C:0005b6 bd03      			out		OCR2, R16
         			
C:0005b7 cffa      			rjmp  	Brake2


Segment usage:
   Code      :      1435 words (2870 bytes)
   Data      :         0 bytes
   EEPROM    :         0 bytes

Assembly completed with no errors.
